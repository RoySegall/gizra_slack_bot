{"pages":[{"title":"Nnutius documentation","text":"Bots? Bots are now the hot thing alongside VR. You may think about bots as an AI entity sitting on the cloud and runs a neural network for knowing any thing about your users. In reality - it's far away from that. Bot are much versatile: Slack bot for your team and automate stuff or monitoring events relate to your clients or your infrastructure and send you information on the various rooms. A Facebook Messenger bot which helps users get information from your site quickly or about events relate to the site. Buy products with buttons through the known text interface. Bot won't replace a site or an application but will be an extra communication path. Slack integration So you understood the need for creating a bot. You looked for a good Slack library that will make it easy but you could not find any. You are right! most of the slack integration are very raw and this is where Nuntius comes to the rescue. Nuntius will integrate with RTM events and give you real-time response for slack events, any events, and with easy API you could implement a task base on the user messages. In addition to that you'll get: Entities to store data in the DB Update mechanism to change stuff in the DB after you deployed your bot CLI commands for install and running updates Webhooks integrations(fully customizable) Cron tasks. Facebook Messenger TBD","tags":"","url":"index.html"},{"title":"Nuntius Slack Bot","text":"Gizra became a company when a lot of the employees are remote: USA, Canada, Spain and the list goes on. That status required from us to start using Slack. But the problem is that we wanted Slack to be cool. The obvious idea is to have a bot. The bot will interact with us and might improve the way we communicate. Origin Like any awesome superhero, Nuntius have an origin story. It's not a tragic origin story when his uncle-CPU died due to lack of understanding that with great power comes great responsibility. Nuntius in Latin means messages. That was the original project - a chat based on any backend technology: Drupal, Wordpress, NodeJS, etc., etc. that could connect to any front end technology(React, Elm, Angular, etc., etc.) and using any WebSocket service(Socket.IO, Pusher, FireBase). The project was too much for a single man but the name lived on. Set up. You'll need PHP 5.6 and above, Composer and RethinkDB. After creating a bot, Go to https:\/\/YOURTEAM.slack.com\/apps. Click on Manage and under Custom integration you'll see your bot. Click on the bot to get the access token. cd settings cp credentials.local.yml credentials.yml Set the proper credentials and then: composer install rethinkdb Now, that you set up credentials file correctly run: php console.php nuntius:install php bot.php That's it. Nuntius is up and running. Integrating Nuntius integrations is done through the hooks.yml file. All the events, entities, tasks and other features(you will soon see) are listed in hooks.yml. In case you forked the project, and that the reasonable scenario, you need to create a hooks.local.yml in the settings directory. The hooks.local.yml allow you to override the definitions in hooks.yml thus gives you the option to swap everything in the system.","tags":"","url":"Nuntius_Slack_Bot.html"},{"title":"Events","text":"Integration with slack can be achieved in various ways. Nuntius implementing the integration via WebSocket and push events AKA RTM events. For any operation on slack, there is a matching RTM event. You can look on the list here. Let's see how to interact with the message events. In the hooks.yml we have the events section: events: presence_change: '\\Nuntius\\Plugin\\PresenceChange' message: '\\Nuntius\\Plugin\\Message' The message key paired with the namespace for the class that needs to implement the logic for the events. Let's have a look at the code: &lt;?php namespace Nuntius\\Plugin; \/** * Class Message. * * Triggered when a message eas sent. *\/ class Message extends NuntiusPluginAbstract { \/** * {@inheritdoc} *\/ public function action() { \/\/ code here... } } Every time someone will send a message the action method will be invoked. On presence change For now, until we will switch to Symfony event dispatcher, events can response to presence change, AKA when the user logged out or in. We use that option to notify the users for the reminders. Let's look on how the message: &lt;?php namespace Nuntius\\Plugin; \/** * Class Message. * * Triggered when a message eas sent. *\/ class Message extends NuntiusPluginAbstract { \/** * {@inheritdoc} *\/ public function actOnPresenceChange() { if ($this-&gt;data['presence'] == 'away') { return; } $rows = $this-&gt;db -&gt;getTable('reminders') -&gt;filter(\\r\\row('user')-&gt;eq($this-&gt;data['user'])) -&gt;run($this-&gt;db-&gt;getConnection()); foreach ($rows as $row) { $result = $row-&gt;getArrayCopy(); $this-&gt;client-&gt;getDMByUserId($result['user'])-&gt;then(function (DirectMessageChannel $channel) use ($result) { \/\/ Send the reminder. $text = 'Hi! You asked me to remind you: ' . $result['reminder']; $this-&gt;client-&gt;send($text, $channel); \/\/ Delete the reminder from the DB. $this-&gt;reminders-&gt;delete($result['id']); }); } } } In this case, we are looking for reminders which the user set and send it as a private message.","tags":"","url":"Events.html"},{"title":"Entities","text":"At some point you might want to keep stuff in the DB. The database is based on Rethinkdb. Similar to event integration definition, entity defined in the hooks.yml file: entities: reminders: '\\Nuntius\\Entity\\Reminders' context: '\\Nuntius\\Entity\\Context' context_archive: '\\Nuntius\\Entity\\RunningContext' running_context: '\\Nuntius\\Entity\\RunningContext' system: '\\Nuntius\\Entity\\System' You could implement methods relate to the entity in the matching class but you will see that the basic methods are enough. Add an entry &lt;?php \\Nuntius\\Nuntius::getEntityManager() -&gt;get('context') -&gt;insert(['foo' =&gt; 'bar']); Load an entry &lt;?php \\Nuntius\\Nuntius::getEntityManager() -&gt;get('context') -&gt;load(ID); Load all the entries &lt;?php \\Nuntius\\Nuntius::getEntityManager() -&gt;get('context') -&gt;loadAll(); Update an entry &lt;?php \\Nuntius\\Nuntius::getEntityManager() -&gt;get('context') -&gt;update(ID, ['foo' =&gt; 'bar']); Delete an entry &lt;?php \\Nuntius\\Nuntius::getEntityManager() -&gt;get('context') -&gt;delete(ID); Query in the DB Except for the CRUD layer, sometimes you need to look for items. Have a look at the code: &lt;?php \\Nuntius\\Nuntius::getRethinkDB() -&gt;getTable('running_context') -&gt;filter(\\r\\row('foo')-&gt;eq('bar')) -&gt;filter(\\r\\row('bar')-&gt;ne('fo')) -&gt;run($this-&gt;db-&gt;getConnection()) -&gt;toArray();","tags":"","url":"Entities.html"},{"title":"introduction","text":"One way to communicate with Nuntius is via text. First, let's have a look at the hooks.yml file: tasks: reminders: '\\Nuntius\\Tasks\\Reminders' help: '\\Nuntius\\Tasks\\Help' introduction: '\\Nuntius\\Tasks\\Introduction' The tasks plugin needs to declare to which text it needs to response AKA scope: There two types of plugins: Black box task - A task that needs arguments, or not, and does a simple job: set a reminder for later. Conversation task - A task which depends on information and can get it by asking the user a couple of questions. Each conversation task has a conversation scope: Forever - a scope that likely won't change in the near future: List of the user's team members. Temporary - A scope that we don't need to keep forever: What you want to eat for lunch. But a temporary scope may not be relevant forever but we might want to use in the future. We would likely want to keep the places the user invited food from so we could suggest that in the past.","tags":"","url":"Tasks\/introduction.html"},{"title":"Black box task","text":"&lt;?php namespace Nuntius\\Tasks; \/** * Remind to the user something to do. *\/ class Reminders extends TaskBaseAbstract implements TaskBaseInterface { \/** * {@inheritdoc} *\/ public function scope() { return [ '\/remind me (.*)\/' =&gt; [ 'human_command' =&gt; 'remind me REMINDER', 'description' =&gt; 'Next time you log in I will remind you what you ' . ' wrote in the REMINDER', 'callback' =&gt; 'addReminder', ], ]; } \/** * Adding a reminder to the DB. * * @param string $reminder * The reminder of the user. * * @return string * You got it dude! *\/ public function addReminder($reminder) { $this-&gt;entityManager-&gt;get('reminders')-&gt;insert([ 'reminder' =&gt; $reminder, 'user' =&gt; $this-&gt;data['user'], ]); return 'OK! I got you covered!'; } } In the method scope we define to which text we need to respond. Each (.*) is an argument. The keys meaning are: human_command: An example of how user input should be. description: Describing what the command will do. callback: The callback which will be invoked with the argument you expect to receive.","tags":"","url":"Tasks\/Black_box_task.html"},{"title":"Conversation task","text":"Let's look first at the code and explain how to write the plugin: &lt;?php namespace Nuntius\\Tasks; \/** * Remind to the user something to do. *\/ class Introduction extends TaskConversationAbstract implements TaskConversationInterface { \/** * {@inheritdoc} *\/ public function scope() { return [ '\/nice to meet you\/' =&gt; [ 'human_command' =&gt; 'nice to meet you', 'description' =&gt; 'We will do a proper introduction', ], ]; } \/** * {@inheritdoc} *\/ public function conversationScope() { return 'forever'; } \/** * Get the user first name. *\/ public function questionFirstName() { return 'Oh hey! It looks that we are not introduced yet. what is your first name?'; } \/** * Get the last name of the user. *\/ public function questionLastName() { return 'what is your last name?'; } \/** * {@inheritdoc} *\/ public function collectAllAnswers() { return 'Well, ' . $this-&gt;answers['FirstName'] . ' ' . $this-&gt;answers['LastName'] . ', it is a pleasure.'; } } First, it's important to implement the TaskConversationInterface interface. This is the way we recognize this a conversation task. Similar to the black box task we do define a scope but in this case, we don't define a callback. That's because nuntius will ask the question by a naming conventions method: methods with a question prefix will be invoked(similar to Unit test). The method needs to return the text of the question. The questions will be triggered by the order in the class - so keep in a rational order of methods. When nuntius collected all the answers, the collectAllAnswers will be invoked. The answers will be available in the answers property with the matching name of the method which holds the question but without the question prefix. In case something got in the way and the user lost his internet connection or the server went down the answers won't get lost. The answers stored in the DB except for a temporary context conversation. The answers will move into an archive and won't be available for next time the conversation will start.","tags":"","url":"Tasks\/Conversation_task.html"},{"title":"Validating user input","text":"When the user is having a conversation with the bot, we need to validate the input. This is valid only for a conversation, and not a black box task, due to the fact that when the task is a black box task you only have a single input but, in a conversation there are multiple steps and we need to make sure the user can't go the next question until the current task input is valid. Adding a constraint to conversation In order for a validating the question input we need to define the constraint on the scope level. Let's look on the restarting tasks task which delete the context of a un-temporary task. The task is implemented at \\Nuntius\\Tasks\\RestartQuestion: \/** * {@inheritdoc} *\/ public function scope() { return [ '\/delete information\/' =&gt; [ 'human_command' =&gt; 'delete information', 'description' =&gt; 'Delete an information', 'constraint' =&gt; '\\Nuntius\\TasksConstraint\\RestartQuestionConstraint', ], ]; } The constraint key define the namespace of class. Validating method will be invoke by a specific pattern. In order to validate the questionStartingAgain method input we need to create a validateStartingAgain. If the method will return TRUE then the input is OK. If the method will return a text the input is bad and the text will be the text that explain why it failed. Let's have a look on the code: \/** * Validate the input of tasks. * * @param $value * The input of the user. * * @return bool|string *\/ public function validateGetTaskId($value) { $tasks = Nuntius::getTasksManager()-&gt;getRestartableTasks(); foreach ($tasks as $task) { if ($task['label'] == $value) { return TRUE; } } return &quot;Hmmm..... it's look like `{$value}` is not a task I know.&quot;; } \/** * Validate the user input the correct text. * * @param string $value * The input of the user. * * @return bool|string *\/ public function validateStartingAgain($value) { if (!in_array($value, ['yes', 'no', 'y', 'n'])) { return 'The answer need to be one of the following: ' . implode(', ' , ['`yes`', '`no`', '`y`', '`n`']); } return TRUE; }","tags":"","url":"Tasks\/Validating_user_input.html"},{"title":"Updates","text":"You deployed nuntius and you added some functionality but that functionality needs some new entities tables, maybe change some information about the user etc. etc. For that case, we have the updates mechanism. Implementing a new update: updates: 1: '\\Nuntius\\Update\\Update1' The code look pretty obvious: &lt;?php namespace Nuntius\\Update; class Update1 implements UpdateBaseInterface { \/** * Describe what the update going to do. * * @return string * What the update going to do. *\/ public function description() { return 'Example update'; } \/** * Running the update. * * @return string * A message for what the update did. *\/ public function update() { return 'You run a simple update. Nothing happens but this update will not run again.'; } } About the methods: description: explain what the update is going to do. update: Preform the update. The text the function will return will show after the update was invoked successfully. A couple of rules: Updates that invoked before won't invoked again. The update will be invoked in the order in the yml file. When installing nuntius, all the listed updates will be marked as updates which invoked already.","tags":"","url":"Updates.html"},{"title":"Commands","text":"Commands are an easy way to add CLI integration. The commands based on the Symfony console component so we won't go and explain the API. You can read about it here Let's have a look on how to define: commands: - '\\Nuntius\\Commands\\UpdateCommand' - '\\Nuntius\\Commands\\InstallCommand' Let's have a look at the code that installs Nuntius for us: &lt;?php namespace Nuntius\\Commands; class InstallCommand extends Command { \/** * {@inheritdoc} *\/ protected function configure() { $this -&gt;setName('nuntius:install') -&gt;setDescription('Install nuntius') -&gt;setHelp('Set up nuntius'); } \/** * {@inheritdoc} *\/ protected function execute(InputInterface $input, OutputInterface $output) { $io = new SymfonyStyle($input, $output); $value = Nuntius::getSettings(); $db = Nuntius::getRethinkDB(); $io-&gt;section(&quot;Setting up the DB.&quot;); $db-&gt;createDB($value['rethinkdb']['db']); $io-&gt;success(&quot;The DB was created&quot;); sleep(5); $io-&gt;section(&quot;Creating entities tables.&quot;); foreach (array_keys($value['entities']) as $scheme) { $db-&gt;createTable($scheme); $io-&gt;success(&quot;The table {$scheme} has created&quot;); } \/\/ Run this again. $db-&gt;getTable('system')-&gt;insert(['id' =&gt; 'updates', 'processed' =&gt; []])-&gt;run($db-&gt;getConnection()); Nuntius::getEntityManager()-&gt;get('system')-&gt;update('updates', ['processed' =&gt; array_keys(Nuntius::getUpdateManager()-&gt;getUpdates())]); $io-&gt;section(&quot;The install has completed.&quot;); $io-&gt;text('run php bot.php'); } }","tags":"","url":"Commands.html"},{"title":"What is webhook","text":"By Wikipedia, a Webhook is: A webhook in web development is a method of augmenting or altering the behavior of a web page, or web application, with custom callbacks. These callbacks may be maintained, modified, and managed by third-party users and developers who may not necessarily be affiliated with the originating website or application. But, this might not tell you a lot(me either) so I'll give an example. Real life example Let's say you want to know about something that happens at a GitHub repo, a Docker Hub project or maybe you want to listen to event from you logs service? With Webhook you can accomplish that. Basically, A Webhook is an HTTP request, with a data(payload) or without, which sent to your server from external server.","tags":"","url":"Webhooks\/What_is_webhook.html"},{"title":"Adding webhook support","text":"Now that you know what is a Webhook you know that you need to set an endpoint. Before we begin let's clear something - the endpoint for the incoming webhooks does not mean for any thing else rather than getting information from external services. i.e - setting an endpoint to display a list of entities is a bad practice. Adding a routing As always, let's go to the hooks.yml file: webhooks_routing: 'github': '\\Nuntius\\WebhooksRounting\\GitHub' The key of the item, in this case, github, will be the endpoint. i.e: http:\/\/address.com\/github The router controller You set the endpoint, let's see how the controller should look: &lt;?php \/** * Handling incoming webhooks from GitHub. *\/ class GitHub implements WebhooksRoutingControllerInterface { \/** * {@inheritdoc} *\/ public function response(Request $request) { \/\/ Logic here. return new JsonResponse(['type' =&gt; 'success', 'message' =&gt; 'The request has been processed.']); } } The controller need to implement the response method and do the logic over there: Maybe dispatch events, insert something to DB or just send a PM on slack. In this, you can see the controller return a JsonResponse but you can return any Response object. As long as you return an object because: The service that sent the webhook might think the request failed if a 2XX or a 5XX response was return. Symfony will fail the page of a Response type won't returned.","tags":"","url":"Webhooks\/Adding_webhook_support.html"},{"title":"Configure the integration","text":"Setting up the configuration is pretty much easy. Go to the repository settings: And now go to the webhooks page: Add a new Webhook: You can set up in the next way: GitHub will send a request to do a sanity check. Just to make sure the address exists. Testing If you want to test the integration you'll right you need that your local host will be acessable. The most easy way to do that is with ngrok. ngrok open your localhost with a temporary address. In my case the address will look like http:\/\/66a4cc4d.ngrok.io\/nuntius-bot\/github. If you want to make sure that something happens you can log it to the logger entity: Nuntius::getEntityManager()-&gt;get('logger')-&gt;insert(['foo' =&gt; 'bar']); And then, to make sure something is going in the DB you can use the built in live entity view option: php console.php nuntius:entity logger live_view This will output the next result in the terminal:","tags":"","url":"Webhooks\/GitHub\/Configure_the_integration.html"},{"title":"Add events integration","text":"Github Yes, there are a lot of slack integrations but most of them pretty generic. They don't provide a real feedback from the bot - bad information in the PR or incorrect information in the issue body. Let's have a look on how to set the integration: webhooks: github: opened: '\\Nuntius\\Webhooks\\GitHub\\Opened' Now, let's have a look at the code: &lt;?php \/** * Acting upon issue or pull request opening. *\/ class Opened extends GitHubWebhooksAbstract implements GitHubWebhooksInterface { \/** * {@inheritdoc} *\/ public function act() { $payload = $this-&gt;data; $key = !empty($payload-&gt;pull_request) ? 'pull_request' : 'issue'; $payload = [ 'event' =&gt; 'open', 'type' =&gt; $key, 'user' =&gt; $payload-&gt;{$key}-&gt;user-&gt;login, 'title' =&gt; $payload-&gt;{$key}-&gt;title, 'body' =&gt; $payload-&gt;{$key}-&gt;body, ]; $this-&gt;logger-&gt;insert([ 'logging' =&gt; 'opened_' . $key, 'payload' =&gt; $payload, ]); } } For now, there is just a logging event. After adding Symfony event dispatcher, you could write a better integration. Post act You can add a logic to the controller that will act after the act method was triggered. That's more suitable for logging stuff rather than implementing a logic: &lt;?php abstract class GitHubWebhooksAbstract implements GitHubWebhooksInterface { \/\/\/ ... \/** * {@inheritdoc} *\/ public function postAct() { $this-&gt;logger-&gt;insert((array) $this-&gt;getData()); } }","tags":"","url":"Webhooks\/GitHub\/Add_events_integration.html"},{"title":"Services","text":"All the managers(will be covered below) defined as Symfony services. In a nutshell, a service is a class which implement a logic and can receive other services as an argument and can be injected to other services as well. For more info go to the DependencyInjection Component documentation. You can add as many services as you'd like to. As always, let's have a look at the hooks.yml file: services: - 'services.local.yml' By default, you can add services in the services.local.yml but if you want to manage that in other files you can add them in the hooks.local.yml file.","tags":"","url":"Services.html"},{"title":"Cron tasks","text":"If you need to run command in a constant period of time such as: sending messages in specific hours, process a lot of data in the DB, you need cron tasks. To enable the cron task you can add in the cront task the next code: *\/1 * * * * PATH_TO_PHP PATH_TO_NUNTIUS\/cron.php &gt;\/dev\/null 2&gt;&amp;1 If you see that the cron task is not triggered, try to give 777 permission to the file. The cron task will be fired each minutes but that should not bother you. Let's have a look on the code. First, the hooks.yml file: cron: log: '\\Nuntius\\Cron\\LogThings' Next, let's look on how to define the cron job: &lt;?php namespace Nuntius\\Cron; class LogThings extends CronTaskAbstract implements CronTaskInterface { \/** * {@inheritdoc} *\/ protected $period = '*\/5 * * * *'; \/** * {@inheritdoc} *\/ public function run() { \/\/ ... } } The $period property will tell to cron what is the periodic rule it's follows. In this case each five minutes. The next par is the run method. In that method you'll apply the logic of the the task.","tags":"","url":"Cron_tasks.html"},{"title":"Managers","text":"Get the settings: &lt;?php \\Nuntius\\Nuntius::getSettings(); Get the DB layer: &lt;?php \\Nuntius\\Nuntius::getRethinkDB(); Get the entity manager: &lt;?php \\Nuntius\\Nuntius::getEntityManager(); Get the task manager: &lt;?php \\Nuntius\\Nuntius::getTasksManager(); Get the update manager: &lt;?php \\Nuntius\\Nuntius::getUpdateManager();","tags":"","url":"Uncovered_API\/Managers.html"},{"title":"Slack how to","text":"How to send a message to the user: &lt;?php namespace Nuntius\\Plugin; \/** * Class Message. * * Triggered when a message eas sent. *\/ class Message extends NuntiusPluginAbstract { \/** * {@inheritdoc} *\/ public function action() { $this-&gt;client-&gt;getDMByUserId('USER_ID')-&gt;then(function (ChannelInterface $channel) { $this-&gt;client-&gt;send('Hi user!', $channel); }); } } Send message in a room: &lt;?php namespace Nuntius\\Plugin; \/** * Class Message. * * Triggered when a message eas sent. *\/ class Message extends NuntiusPluginAbstract { \/** * {@inheritdoc} *\/ public function action() { $this-&gt;client-&gt;getChannelById('ROOM_ID')-&gt;then(function (ChannelInterface $channel) { $this-&gt;client-&gt;send('Hi there room members', $channel); }); } } Send a message to a user when outside a room context AKA HTTP RPC-style: &lt;?php $slack_http = new SlackHttpService(); $slack = $slack_http-&gt;setAccessToken(Nuntius::getSettings()-&gt;getSetting('access_token')); $im_room = $slack-&gt;Im()-&gt;getImForUser($slack-&gt;Users()-&gt;getUserByName(strtolower($info['username']))); $message = new SlackHttpPayloadServicePostMessage(); $message -&gt;setChannel($im_room) -&gt;setText($info['text']); \/\/ Posting the message. $slack-&gt;Chat()-&gt;postMessage($message); For more options look on \\Nuntius\\Examples\\GitHubOpened\\NuntiusGitHubOpenedExample::postMessage","tags":"","url":"Uncovered_API\/Slack_how_to.html"},{"title":"Tests","text":"In order to test GitHub webhooks set the local env variable NUNTIUS_BASE_URL to the address of your nuntius installation: export NUNTIUS_BASE_URL=http:\/\/localhost:8888 After that fire up the test server: php -S localhost:8888 Running tests is easy: bash tests.sh","tags":"","url":"Tests.html"}]}