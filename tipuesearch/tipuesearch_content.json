{"pages":[{"title":"Nnutius documentation","text":"Bots? Bots are now the hot thing alongside VR. You may think about bots as an AI entity sitting on the cloud and runs a neural network for knowing any thing about your users. In reality - it's far away from that. Bot are much versatile: Slack bot for your team and automate stuff or monitoring events relate to your clients or your infrastructure and send you information on the various rooms. A Facebook Messenger bot which helps users get information from your site quickly or about events relate to the site. Buy products with buttons through the known text interface. Bot won't replace a site or an application but will be an extra communication path. Slack integration So you understood the need for creating a bot. You looked for a good Slack library that will make it easy but you could not find any. You are right! most of the slack integration are very raw and this is where Nuntius comes to the rescue. Nuntius will integrate with RTM events and give you real-time response for slack events, any events, and with easy API you could implement a task base on the user messages. In addition to that you'll get: Entities to store data in the DB Update mechanism to change stuff in the DB after you deployed your bot CLI commands for install and running updates Webhooks integrations(fully customizable) Cron tasks. Facebook Messenger TBD","tags":"","url":"index.html"},{"title":"Nuntius Slack Bot","text":"Gizra became a company when a lot of the employees are remote: USA, Canada, Spain and the list goes on. That status required from us to start using Slack. But the problem is that we wanted Slack to be cool. The obvious idea is to have a bot. The bot will interact with us and might improve the way we communicate. Origin Like any awesome superhero, Nuntius have an origin story. It's not a tragic origin story when his uncle-CPU died due to lack of understanding that with great power comes great responsibility. Nuntius in Latin means messages. That was the original project - a chat based on any backend technology: Drupal, Wordpress, NodeJS, etc., etc. that could connect to any front end technology(React, Elm, Angular, etc., etc.) and using any WebSocket service(Socket.IO, Pusher, FireBase). The project was too much for a single man but the name lived on. Set up. You'll need PHP 5.6 and above, Composer and RethinkDB. After creating a bot, Go to https:\/\/YOURTEAM.slack.com\/apps. Click on Manage and under Custom integration you'll see your bot. Click on the bot to get the access token. Install composer components and start RethinkDB: composer install rethinkdb Let's start and run the installe: php console.php nuntius:install After that will finish you need to run php console.php nuntius:run That's it. Nuntius is up and running. Integrating Nuntius integrations is done through the hooks.yml file. All the events, entities, tasks and other features(you will soon see) are listed in hooks.yml. In case you forked the project, and that the reasonable scenario, you need to create a hooks.local.yml in the settings directory. The hooks.local.yml allow you to override the definitions in hooks.yml thus gives you the option to swap everything in the system.","tags":"","url":"Nuntius_Slack_Bot.html"},{"title":"Events","text":"Integration with slack can be achieved in various ways. Nuntius implementing the integration via WebSocket and push events AKA RTM events. For any operation on slack, there is a matching RTM event. You can look on the list here. Let's see how to interact with the message events. In the hooks.yml we have the events section: events: presence_change: '\\Nuntius\\Plugin\\PresenceChange' message: '\\Nuntius\\Plugin\\Message' The message key paired with the namespace for the class that needs to implement the logic for the events. Let's have a look at the code: &lt;?php namespace Nuntius\\Plugin; \/** * Class Message. * * Triggered when a message eas sent. *\/ class Message extends NuntiusPluginAbstract { \/** * {@inheritdoc} *\/ public function action() { \/\/ code here... } } Every time someone will send a message the action method will be invoked. On presence change For now, until we will switch to Symfony event dispatcher, events can response to presence change, AKA when the user logged out or in. We use that option to notify the users for the reminders. Let's look on how the message: &lt;?php namespace Nuntius\\Plugin; \/** * Remind to the user something to do. *\/ class Reminders extends TaskBaseAbstract implements TaskBaseInterface { \/** * {@inheritdoc} *\/ public function actOnPresenceChange() { if ($this-&gt;data['presence'] == 'away') { return; } $rows = $this-&gt;query -&gt;table('reminders') -&gt;condition('user', $this-&gt;data['user']) -&gt;execute(); foreach ($rows as $row) { $this-&gt;client-&gt;getDMByUserId($row['user'])-&gt;then(function (DirectMessageChannel $channel) use ($row) { \/\/ Send the reminder. $text = 'Hi! You asked me to remind you: ' . $row['reminder']; $this-&gt;client-&gt;send($text, $channel); \/\/ Delete the reminder from the DB. $this-&gt;reminders-&gt;delete($row['id']); }); } } } In this case, we are looking for reminders which the user set and send it as a private message.","tags":"","url":"Events.html"},{"title":"Entities","text":"At some point you might want to keep stuff in the DB. The database is based on Rethinkdb. Similar to event integration definition, entity defined in the hooks.yml file: entities: reminders: '\\Nuntius\\Entity\\Reminders' context: '\\Nuntius\\Entity\\Context' context_archive: '\\Nuntius\\Entity\\RunningContext' running_context: '\\Nuntius\\Entity\\RunningContext' system: '\\Nuntius\\Entity\\System' You could implement methods relate to the entity in the matching class but you will see that the basic methods are enough. Add an entry &lt;?php \\Nuntius\\Nuntius::getEntityManager() -&gt;get('context') -&gt;insert(['foo' =&gt; 'bar']); Load an entry &lt;?php \\Nuntius\\Nuntius::getEntityManager() -&gt;get('context') -&gt;load(ID); Load multiple entries You can ask for all of them: &lt;?php \\Nuntius\\Nuntius::getEntityManager() -&gt;get('context') -&gt;loadMultiple(); Or you can ask for multiple entities: &lt;?php \\Nuntius\\Nuntius::getEntityManager() -&gt;get('context') -&gt;loadMultiple(['id1', 'id2', 'id3']); Update an entry &lt;?php \\Nuntius\\Nuntius::getEntityManager() -&gt;get('context') -&gt;update(['id' =&gt; 'ID', 'foo' =&gt; 'bar']); Delete from the DB You can delete a single entity: &lt;?php \\Nuntius\\Nuntius::getEntityManager() -&gt;get('context') -&gt;delete('id'); You can multiple entities: &lt;?php \\Nuntius\\Nuntius::getEntityManager() -&gt;get('context') -&gt;deleteMultiple(['id1', 'id2', 'id3']); Or you can delete all the entities: &lt;?php \\Nuntius\\Nuntius::getEntityManager() -&gt;get('context') -&gt;deleteMultiple();","tags":"","url":"Entities.html"},{"title":"introduction","text":"One way to communicate with Nuntius is via text. First, let's have a look at the hooks.yml file: tasks: reminders: '\\Nuntius\\Tasks\\Reminders' help: '\\Nuntius\\Tasks\\Help' introduction: '\\Nuntius\\Tasks\\Introduction' The tasks plugin needs to declare to which text it needs to response AKA scope: There two types of plugins: Black box task - A task that needs arguments, or not, and does a simple job: set a reminder for later. Conversation task - A task which depends on information and can get it by asking the user a couple of questions. Each conversation task has a conversation scope: Forever - a scope that likely won't change in the near future: List of the user's team members. Temporary - A scope that we don't need to keep forever: What you want to eat for lunch. But a temporary scope may not be relevant forever but we might want to use in the future. We would likely want to keep the places the user invited food from so we could suggest that in the past.","tags":"","url":"Tasks\/introduction.html"},{"title":"Black box task","text":"&lt;?php namespace Nuntius\\Tasks; \/** * Remind to the user something to do. *\/ class Reminders extends TaskBaseAbstract implements TaskBaseInterface { \/** * {@inheritdoc} *\/ public function scope() { return [ '\/remind me (.*)\/' =&gt; [ 'human_command' =&gt; 'remind me REMINDER', 'description' =&gt; 'Next time you log in I will remind you what you ' . ' wrote in the REMINDER', 'callback' =&gt; 'addReminder', ], ]; } \/** * Adding a reminder to the DB. * * @param string $reminder * The reminder of the user. * * @return string * You got it dude! *\/ public function addReminder($reminder) { $this-&gt;reminders-&gt;save([ 'reminder' =&gt; $reminder, 'user' =&gt; $this-&gt;data['user'], ]); return 'OK! I got you covered!'; } } In the method scope we define to which text we need to respond. Each (.*) is an argument. The keys meaning are: human_command: An example of how user input should be. description: Describing what the command will do. callback: The callback which will be invoked with the argument you expect to receive.","tags":"","url":"Tasks\/Black_box_task.html"},{"title":"Conversation task","text":"Let's look first at the code and explain how to write the plugin: &lt;?php namespace Nuntius\\Tasks; \/** * Remind to the user something to do. *\/ class Introduction extends TaskConversationAbstract implements TaskConversationInterface { \/** * {@inheritdoc} *\/ public function scope() { return [ '\/nice to meet you\/' =&gt; [ 'human_command' =&gt; 'nice to meet you', 'description' =&gt; 'We will do a proper introduction', ], ]; } \/** * {@inheritdoc} *\/ public function conversationScope() { return 'forever'; } \/** * Get the user first name. *\/ public function questionFirstName() { return 'Oh hey! It looks that we are not introduced yet. what is your first name?'; } \/** * Get the last name of the user. *\/ public function questionLastName() { return 'what is your last name?'; } \/** * {@inheritdoc} *\/ public function collectAllAnswers() { return 'Well, ' . $this-&gt;answers['FirstName'] . ' ' . $this-&gt;answers['LastName'] . ', it is a pleasure.'; } } First, it's important to implement the TaskConversationInterface interface. This is the way we recognize this a conversation task. Similar to the black box task we do define a scope but in this case, we don't define a callback. That's because nuntius will ask the question by a naming conventions method: methods with a question prefix will be invoked(similar to Unit test). The method needs to return the text of the question. The questions will be triggered by the order in the class - so keep in a rational order of methods. When nuntius collected all the answers, the collectAllAnswers will be invoked. The answers will be available in the answers property with the matching name of the method which holds the question but without the question prefix. In case something got in the way and the user lost his internet connection or the server went down the answers won't get lost. The answers stored in the DB except for a temporary context conversation. The answers will move into an archive and won't be available for next time the conversation will start.","tags":"","url":"Tasks\/Conversation_task.html"},{"title":"Validating user input","text":"When the user is having a conversation with the bot, we need to validate the input. This is valid only for a conversation, and not a black box task, due to the fact that when the task is a black box task you only have a single input but, in a conversation there are multiple steps and we need to make sure the user can't go the next question until the current task input is valid. Adding a constraint to conversation In order for a validating the question input we need to define the constraint on the scope level. Let's look on the restarting tasks task which delete the context of a un-temporary task. The task is implemented at \\Nuntius\\Tasks\\RestartQuestion: \/** * {@inheritdoc} *\/ public function scope() { return [ '\/delete information\/' =&gt; [ 'human_command' =&gt; 'delete information', 'description' =&gt; 'Delete an information', 'constraint' =&gt; '\\Nuntius\\TasksConstraint\\RestartQuestionConstraint', ], ]; } The constraint key define the namespace of class. Validating method will be invoke by a specific pattern. In order to validate the questionStartingAgain method input we need to create a validateStartingAgain. If the method will return TRUE then the input is OK. If the method will return a text the input is bad and the text will be the text that explain why it failed. Let's have a look on the code: \/** * Validate the input of tasks. * * @param $value * The input of the user. * * @return bool|string *\/ public function validateGetTaskId($value) { $tasks = Nuntius::getTasksManager()-&gt;getRestartableTasks(); foreach ($tasks as $task) { if ($task['label'] == $value) { return TRUE; } } return &quot;Hmmm..... it's look like `{$value}` is not a task I know.&quot;; } \/** * Validate the user input the correct text. * * @param string $value * The input of the user. * * @return bool|string *\/ public function validateStartingAgain($value) { if (!in_array($value, ['yes', 'no', 'y', 'n'])) { return 'The answer need to be one of the following: ' . implode(', ' , ['`yes`', '`no`', '`y`', '`n`']); } return TRUE; }","tags":"","url":"Tasks\/Validating_user_input.html"},{"title":"Updates","text":"You deployed nuntius and you added some functionality but that functionality needs some new entities tables, maybe change some information about the user etc. etc. For that case, we have the updates mechanism. Implementing a new update: updates: 1: '\\Nuntius\\Update\\Update1' The code look pretty obvious: &lt;?php namespace Nuntius\\Update; class Update1 implements UpdateBaseInterface { \/** * Describe what the update going to do. * * @return string * What the update going to do. *\/ public function description() { return 'Example update'; } \/** * Running the update. * * @return string * A message for what the update did. *\/ public function update() { return 'You run a simple update. Nothing happens but this update will not run again.'; } } About the methods: description: explain what the update is going to do. update: Preform the update. The text the function will return will show after the update was invoked successfully. A couple of rules: Updates that invoked before won't invoked again. The update will be invoked in the order in the yml file. When installing nuntius, all the listed updates will be marked as updates which invoked already.","tags":"","url":"Updates.html"},{"title":"Commands","text":"Commands are an easy way to add CLI integration. The commands based on the Symfony console component so we won't go and explain the API. You can read about it here Let's have a look on how to define: commands: - '\\Nuntius\\Commands\\UpdateCommand' - '\\Nuntius\\Commands\\InstallCommand' Let's have a look at the code that installs Nuntius for us: &lt;?php namespace Nuntius\\Commands; class InstallCommand extends Command { \/** * {@inheritdoc} *\/ protected function configure() { $this -&gt;setName('nuntius:install') -&gt;setDescription('Install nuntius') -&gt;setHelp('Set up nuntius'); } \/** * {@inheritdoc} *\/ protected function execute(InputInterface $input, OutputInterface $output) { $io = new SymfonyStyle($input, $output); if (!file_exists(__DIR__ . '\/..\/..\/settings\/credentials.local.yml')) { $question = new ConfirmationQuestion('The credentials yml file is missing. Would you like to generate the file?'); if (!$io-&gt;askQuestion($question)) { $io-&gt;block('Well then, you need to create a copy of the file credentials.yml to credentials.local.yml and populate the values. Good luck!'); return; } $this-&gt;generateCredentials($io); } $value = Nuntius::getSettings()-&gt;getSettings(); $operations = Nuntius::getDb()-&gt;getOperations(); $storage = Nuntius::getDb()-&gt;getStorage(); $io-&gt;section(&quot;Setting up the DB.&quot;); if ($operations-&gt;dbExists($value['rethinkdb']['db'])) { $io-&gt;success(&quot;The DB already exists, skipping.&quot;); } else { $operations-&gt;dbCreate($value['rethinkdb']['db']); $io-&gt;success(&quot;The DB was created&quot;); sleep(5); } $io-&gt;section(&quot;Creating entities tables.&quot;); foreach (array_keys($value['entities']) as $table) { if ($operations-&gt;tableExists($table)) { $io-&gt;success(&quot;The table {$table} already exists, skipping.&quot;); } else { $operations-&gt;tableCreate($table); $io-&gt;success(&quot;The table {$table} has created&quot;); } } \/\/ Run this again. $storage-&gt;table('system')-&gt;save(['id' =&gt; 'updates', 'processed' =&gt; array_keys(Nuntius::getUpdateManager()-&gt;getUpdates())]); $io-&gt;section(&quot;The install has completed.&quot;); $io-&gt;text('run php console.php nuntius:run'); } }","tags":"","url":"Commands.html"},{"title":"What is webhook","text":"By Wikipedia, a Webhook is: A webhook in web development is a method of augmenting or altering the behavior of a web page, or web application, with custom callbacks. These callbacks may be maintained, modified, and managed by third-party users and developers who may not necessarily be affiliated with the originating website or application. But, this might not tell you a lot(me either) so I'll give an example. Real life example Let's say you want to know about something that happens at a GitHub repo, a Docker Hub project or maybe you want to listen to event from you logs service? With Webhook you can accomplish that. Basically, A Webhook is an HTTP request, with a data(payload) or without, which sent to your server from external server.","tags":"","url":"Webhooks\/What_is_webhook.html"},{"title":"Adding webhook support","text":"Now that you know what is a Webhook you know that you need to set an endpoint. Before we begin let's clear something - the endpoint for the incoming webhooks does not mean for any thing else rather than getting information from external services. i.e - setting an endpoint to display a list of entities is a bad practice. Adding a routing As always, let's go to the hooks.yml file: webhooks_routing: 'github': '\\Nuntius\\WebhooksRounting\\GitHub' The key of the item, in this case, github, will be the endpoint. i.e: http:\/\/address.com\/github The router controller You set the endpoint, let's see how the controller should look: &lt;?php \/** * Handling incoming webhooks from GitHub. *\/ class GitHub implements WebhooksRoutingControllerInterface { \/** * {@inheritdoc} *\/ public function response(Request $request) { \/\/ Logic here. return new JsonResponse(['type' =&gt; 'success', 'message' =&gt; 'The request has been processed.']); } } The controller need to implement the response method and do the logic over there: Maybe dispatch events, insert something to DB or just send a PM on slack. In this, you can see the controller return a JsonResponse but you can return any Response object. As long as you return an object because: The service that sent the webhook might think the request failed if a 2XX or a 5XX response was return. Symfony will fail the page of a Response type won't returned.","tags":"","url":"Webhooks\/Adding_webhook_support.html"},{"title":"Configure the integration","text":"Setting up the configuration is pretty much easy. Go to the repository settings: And now go to the webhooks page: Add a new Webhook: You can set up in the next way: GitHub will send a request to do a sanity check. Just to make sure the address exists. Testing If you want to test the integration you'll right you need that your local host will be acessable. The most easy way to do that is with ngrok. ngrok open your localhost with a temporary address. In my case the address will look like http:\/\/66a4cc4d.ngrok.io\/nuntius-bot\/github. If you want to make sure that something happens you can log it to the logger entity: Nuntius::getEntityManager()-&gt;get('logger')-&gt;insert(['foo' =&gt; 'bar']); And then, to make sure something is going in the DB you can use the built in live entity view option: php console.php nuntius:entity logger live_view This will output the next result in the terminal:","tags":"","url":"Webhooks\/GitHub\/Configure_the_integration.html"},{"title":"Add events integration","text":"Github Yes, there are a lot of slack integrations but most of them pretty generic. They don't provide a real feedback from the bot - bad information in the PR or incorrect information in the issue body. Let's have a look on how to set the integration: webhooks: github: opened: '\\Nuntius\\Webhooks\\GitHub\\Opened' Now, let's have a look at the code: &lt;?php \/** * Acting upon issue or pull request opening. *\/ class Opened extends GitHubWebhooksAbstract implements GitHubWebhooksInterface { \/** * {@inheritdoc} *\/ public function act() { $payload = $this-&gt;data; $key = !empty($payload-&gt;pull_request) ? 'pull_request' : 'issue'; $payload = [ 'event' =&gt; 'open', 'type' =&gt; $key, 'user' =&gt; $payload-&gt;{$key}-&gt;user-&gt;login, 'title' =&gt; $payload-&gt;{$key}-&gt;title, 'body' =&gt; $payload-&gt;{$key}-&gt;body, ]; $this-&gt;logger-&gt;insert([ 'logging' =&gt; 'opened_' . $key, 'payload' =&gt; $payload, ]); } } For now, there is just a logging event. After adding Symfony event dispatcher, you could write a better integration. Post act You can add a logic to the controller that will act after the act method was triggered. That's more suitable for logging stuff rather than implementing a logic: &lt;?php abstract class GitHubWebhooksAbstract implements GitHubWebhooksInterface { \/\/\/ ... \/** * {@inheritdoc} *\/ public function postAct() { $this-&gt;logger-&gt;save((array) $this-&gt;getData()); } }","tags":"","url":"Webhooks\/GitHub\/Add_events_integration.html"},{"title":"Services","text":"All the managers(will be covered below) defined as Symfony services. In a nutshell, a service is a class which implement a logic and can receive other services as an argument and can be injected to other services as well. For more info go to the DependencyInjection Component documentation. You can add as many services as you'd like to. As always, let's have a look at the hooks.yml file: services: - 'services.local.yml' By default, you can add services in the services.local.yml but if you want to manage that in other files you can add them in the hooks.local.yml file.","tags":"","url":"Services.html"},{"title":"Cron tasks","text":"If you need to run command in a constant period of time such as: sending messages in specific hours, process a lot of data in the DB, you need cron tasks. To enable the cron task you can add in the cront task the next code: *\/1 * * * * PATH_TO_PHP PATH_TO_NUNTIUS\/cron.php &gt;\/dev\/null 2&gt;&amp;1 If you see that the cron task is not triggered, try to give 777 permission to the file. The cron task will be fired each minutes but that should not bother you. Let's have a look on the code. First, the hooks.yml file: cron: log: '\\Nuntius\\Cron\\LogThings' Next, let's look on how to define the cron job: &lt;?php namespace Nuntius\\Cron; class LogThings extends CronTaskAbstract implements CronTaskInterface { \/** * {@inheritdoc} *\/ protected $period = '*\/5 * * * *'; \/** * {@inheritdoc} *\/ public function run() { \/\/ ... } } The $period property will tell to cron what is the periodic rule it's follows. In this case each five minutes. The next par is the run method. In that method you'll apply the logic of the the task.","tags":"","url":"Cron_tasks.html"},{"title":"Intorduction","text":"At the beginning the DB layer was designed to work with only RethinkDB but, one of Nuntius ideas is that 98% of the components are swappable - any one can replace any core components since all of the integration specified in the settings.yml file. So, the DB layer was abstracted and split into four elements(which we will cover in the upcoming parts). Another reason is the on boarding process of new developers which need to know how to talk with RethinkDB. Before the change you would need to do something like: &lt;?php \\Nuntius\\Nuntius::getRethinkDB() -&gt;getTable('running_context') -&gt;filter(\\r\\row('foo')-&gt;eq('bar')) -&gt;filter(\\r\\row('bar')-&gt;ne('fo')) -&gt;run($this-&gt;db-&gt;getConnection()) -&gt;toArray(); Not very nice and intuitive. After the abstraction you need to do: &lt;?php \\Nuntius\\Nuntius::getDb() -&gt;getQuery() -&gt;table('running_context') -&gt;condition('foo', 'bar') -&gt;condition('bar', 'fo') -&gt;execute(); Much better. Go Deep into the rabbit hole part to see the available methods and what you can do.","tags":"","url":"The_DB_layer\/Intorduction.html"},{"title":"Deep into the rabbit hole","text":"As most of the API in Nuntius, the DB layer is accessible using a service. Three ways are defined as best practice: First, aliasing from Nuntius static methods: &lt;?php \\Nuntius\\Nuntius::getDb(); The second is just calling the service: &lt;?php \\Nuntius\\Nuntius::container()-&gt;get('db'); The third one is the best one when writing a service: services: manager.entity: class: \\Nuntius\\EntityManager arguments: ['@db', '@config'] And you service should look like: &lt;?php namespace Nuntius; use Nuntius\\Db\\DbDispatcher; \/** * Entity mananger. *\/ class EntityManager { function __construct(DbDispatcher $db, NuntiusConfig $config) { $this-&gt;db = $db; } \/\/\/ ... } Know you your methods The \\Nuntius\\Nuntius::getDb(); will get give you access to couple of methods: Nuntius::getDb()-&gt;getQuery(): The query part, which you know for the previous page, which allow you to query the DB and get arrays of rows match your query. Nuntius::getDb()-&gt;getStorage(): CRUD(Create, Read, Update, Delete) operation on the table in the DB. Nuntius::getDb()-&gt;getOperations(): Creating and delete databases, tables and indexes(very hard core!). Nuntius::getDb()-&gt;getMetadata(): Get information about the DB: the type, description and text when the user will install Nuntius. More information will be provided in the Writing a custom driver part.","tags":"","url":"The_DB_layer\/Deep_into_the_rabbit_hole.html"},{"title":"Writing a custom driver","text":"Writing a custom DB driver comes for one reason only: you love a DB. That DB is part of your daily stack and you don't want to to start using another DB. That's OK. As any integration, we will start with the hooks.yml file. Let's see how we added rethinkdb into the db_drivers: db_drivers: rethinkdb: metadata: '\\Nuntius\\Db\\RethinkDB\\RethinkDbMetadataHandler' operations: '\\Nuntius\\Db\\RethinkDB\\RethinkDbOperationHandler' query: '\\Nuntius\\Db\\RethinkDB\\RethinkDbQueryHandler' storage: '\\Nuntius\\Db\\RethinkDB\\RethinkDbStorageHandler' The order of the items is not mandatory but could be much more easy to implement in that order.","tags":"","url":"The_DB_layer\/Writing_a_custom_driver\/Writing_a_custom_driver.html"},{"title":"Metadata","text":"The metadata part will describe the DB and what it can do. Let's take a look on RethinkDB: &lt;?php \/** * RethinkDB metadata handler. *\/ class RethinkDbMetadataHandler implements DbMetadataHandlerInterface { \/** * {@inheritdoc} *\/ public function dbType() { return 'NoSQL'; } \/** * {@inheritdoc} *\/ public function installerDescription() { return 'No SQL light weight DB with real time support.'; } \/** * {@inheritdoc} *\/ public function supportRealTime() { return TRUE; } } dbType(): What the DB type: A NoSQL or SQL. installerDescription(): Small description on the DB. It will appear in the installation and provide to the user information about the DB and why the choose the DB as the daily driver. supportRealTime(): One of nuntius commands allows you to see live changes in a table. For the command to work, the DB metadata need to tell if the DB support real time or not.","tags":"","url":"The_DB_layer\/Writing_a_custom_driver\/Metadata.html"},{"title":"Operation","text":"The operation part is the one of the hard core parts in the driver; It's suppose to handle creation and deletion of databases, tables and indexes: &lt;?php namespace Nuntius\\Db\\RethinkDB; use Nuntius\\Db\\DbOperationHandlerInterface; use Nuntius\\Nuntius; \/** * RethinkDB operation handler. *\/ class RethinkDbOperationHandler implements DbOperationHandlerInterface { \/** * The rethinkDB service. * * @var \\Nuntius\\NuntiusRethinkdb *\/ protected $rethinkDB; \/** * The connection object. * * @var \\r\\Connection *\/ protected $connection; \/** * The DB name. * * @var string *\/ protected $db; \/** * Constructing. *\/ function __construct() { $this-&gt;rethinkDB = @Nuntius::getRethinkDB(); $this-&gt;connection = $this-&gt;rethinkDB-&gt;getConnection(); $this-&gt;db = Nuntius::getSettings()-&gt;getSetting('rethinkdb')['db']; } \/** * {@inheritdoc} *\/ public function connected() { return $this-&gt;connection; } \/** * {@inheritdoc} *\/ public function getError() { return $this-&gt;rethinkDB-&gt;error; } \/** * {@inheritdoc} *\/ public function dbCreate($db) { \\r\\dbCreate($db)-&gt;run($this-&gt;connection); return $this; } \/** * {@inheritdoc} *\/ public function dbDrop($db) { \\r\\dbDrop($db)-&gt;run($this-&gt;connection); return $this; } \/** * {@inheritdoc} *\/ public function dbList() { return \\r\\dbList()-&gt;run($this-&gt;connection); } \/** * {@inheritdoc} *\/ public function dbExists($db) { return in_array($db, $this-&gt;dbList()); } \/** * {@inheritdoc} *\/ public function tableCreate($table) { \\r\\db($this-&gt;db)-&gt;tableCreate($table)-&gt;run($this-&gt;connection); return $this; } \/** * {@inheritdoc} *\/ public function tableDrop($table) { \\r\\db($this-&gt;db)-&gt;tableDrop($table)-&gt;run($this-&gt;connection); return $this; } \/** * {@inheritdoc} *\/ public function tableList() { return \\r\\db($this-&gt;db)-&gt;tableList()-&gt;run($this-&gt;connection); } \/** * {@inheritdoc} *\/ public function tableExists($table) { return in_array($table, $this-&gt;tableList()); } \/** * {@inheritdoc} *\/ public function indexCreate($table, $column) { \\r\\db($this-&gt;db)-&gt;table($table)-&gt;indexCreate($column)-&gt;run($this-&gt;connection); return $this; } \/** * {@inheritdoc} *\/ public function indexDrop($table, $column) { \\r\\db($this-&gt;db)-&gt;table($table)-&gt;indexDrop($column)-&gt;run($this-&gt;connection); return $this; } \/** * {@inheritdoc} *\/ public function indexList($table) { return \\r\\db($this-&gt;db)-&gt;table($table)-&gt;indexList()-&gt;run($this-&gt;connection); } \/** * Making sure the index exists in a table. * * @param $table * The table name. * @param $column * The columns name. * * @return bool *\/ public function indexExists($table, $column) { return in_array($column, $this-&gt;indexList($table)); } } The code is pretty much self explanatory but it's contains a template on which we can understand the code better: Please note that X is relate to the part we need to take care of: db, table or index AKA responsibility segment XCreate(): Create X in the responsibility segment. XDrop(): Remove X from responsibility segment. XList(): Return list of X responsibility segment. XExists(): Check if we already have a matching entity in the responsibility segment.","tags":"","url":"The_DB_layer\/Writing_a_custom_driver\/Operation.html"},{"title":"Query","text":"The query part will help you to search for stuff in the DB. Let's have a look on the code: &lt;?php namespace Nuntius\\Db\\RethinkDB; use Nuntius\\Db\\DbQueryHandlerInterface; use r\\Exceptions\\RqlException; use r\\ValuedQuery\\RVar; \/** * RethinkDB query handler. *\/ class RethinkDbQueryHandler implements DbQueryHandlerInterface { \/** * {@inheritdoc} *\/ public function table($table) { $this-&gt;table = $table; return $this; } \/** * {@inheritdoc} *\/ public function condition($property, $value, $operator = '=') { $this-&gt;conditions[] = [ 'property' =&gt; $property, 'value' =&gt; $value, 'operator' =&gt; $operator, ]; return $this; } \/** * {@inheritdoc} *\/ public function pager($start, $length) { $this-&gt;range = [ 'start' =&gt; $start, 'length' =&gt; $length, ]; return $this; } \/** * {@inheritdoc} *\/ public function orderBy($field, $direction) { $this-&gt;sort[] = [ 'field' =&gt; $field, 'direction' =&gt; $direction, ]; return $this; } \/** * Set the mode of the changes flag. * * @param bool $mode * The mode of the flag. * * @return RethinkDbQueryHandler * The current instance. *\/ public function setChanges($mode = TRUE) { $this-&gt;changes = $mode; return $this; } \/** * Return the changes flag. * * @return bool *\/ public function getChanges() { return $this-&gt;changes; } \/** * {@inheritdoc} *\/ public function execute() { $query = \\r\\table($this-&gt;table); if ($this-&gt;conditions) { foreach ($this-&gt;conditions as $condition) { $operator = !empty($condition['operator']) ? $condition['operator'] : '='; if (!in_array($operator, array_keys($this-&gt;operators))) { throw new RqlException(&quot;The operator {$operator} does not allowed. Only &quot; . implode(', ', array_keys($this-&gt;operators))); } if ($operator == 'IN') { $row = function(RVar $doc) use ($condition) { return \\r\\expr($condition['value'])-&gt;contains($doc-&gt;getField($condition['property'])); }; } else { $row = \\r\\row($condition['property'])-&gt;{$this-&gt;operators[$operator]}($condition['value']); } $query = $query-&gt;filter($row); } } if ($this-&gt;range) { $query = $query-&gt;slice($this-&gt;range['start'], $this-&gt;range['length']); } if ($this-&gt;sort) { foreach ($this-&gt;sort as $sort) { $sort['field'] = empty($sort['field']) ? 'id' : $sort['field']; $sort_object = $sort['direction'] == 'ASC' ? \\r\\asc($sort['field']) : \\r\\desc($sort['field']); $query = $query-&gt;orderBy($sort_object); } } if ($this-&gt;changes) { return $query-&gt;changes()-&gt;run($this-&gt;rethinkDB-&gt;getConnection()); } $items = []; foreach ($query-&gt;run($this-&gt;rethinkDB-&gt;getConnection()) as $item) { $item_copy = $item-&gt;getArrayCopy(); $items[] = $item_copy; } $this-&gt;cleanUp(); return $items; } \/** * {@inheritdoc} *\/ public function cleanUp() { $this-&gt;table = ''; $this-&gt;conditions = []; $this-&gt;sort = []; $this-&gt;range = []; } } Each method is pretty explained in the docs and name. Except for the cleanUp(). That's one is important since there are parts that use the same object to query the DB. The clean up method remove query settings from previous and promise the query will be done with out any issues.","tags":"","url":"The_DB_layer\/Writing_a_custom_driver\/Query.html"},{"title":"Storage","text":"The storage part handles the CRUD operation on tables in the DB. Let's look on RethinkDB implementation: &lt;?php \/** * RethinkDB storage handler. *\/ class RethinkDbStorageHandler implements DbStorageHandlerInterface { \/** * Constructing. *\/ function __construct() { $this-&gt;rethinkdb = Nuntius::getRethinkDB(); $this-&gt;connection = $this-&gt;rethinkdb-&gt;getConnection(); } \/** * {@inheritdoc} *\/ public function table($table) { $this-&gt;table = $table; return $this; } \/** * Get the table handler. * * @return \\r\\Queries\\Tables\\Table *\/ public function getTable() { return \\r\\db(Nuntius::getSettings()-&gt;getSetting('rethinkdb')['db']) -&gt;table($this-&gt;table); } \/** * {@inheritdoc} *\/ public function save($document) { if (!isset($document['time'])) { $document['time'] = time(); } $result = $this-&gt;getTable()-&gt;insert($document)-&gt;run($this-&gt;connection)-&gt;getArrayCopy(); if (!isset($document['id'])) { $document['id'] = isset($result['generated_keys']) ? reset($result['generated_keys']) : $result['id']; } return $document; } \/** * {@inheritdoc} *\/ public function load($id) { $items = $this-&gt;loadMultiple(array($id)); return reset($items); } \/** * {@inheritdoc} *\/ public function loadMultiple(array $ids = []) { $query = Nuntius::getDb()-&gt;getQuery() -&gt;table($this-&gt;table); if ($ids) { $query-&gt;condition('id', $ids, 'IN'); } return $query-&gt;execute(); } \/** * {@inheritdoc} *\/ public function update($document) { $this-&gt;getTable()-&gt;get($document['id'])-&gt;update($document)-&gt;run($this-&gt;connection); return $document; } \/** * {@inheritdoc} *\/ public function delete($id) { $this-&gt;deleteMultiple([$id]); } \/** * {@inheritdoc} *\/ public function deleteMultiple(array $ids = []) { $query = $this-&gt;getTable(); if ($ids) { $query-&gt;getAll(\\r\\args($ids)); } $query-&gt;delete()-&gt;run($this-&gt;connection); } } Let's have a quick look on the methods: save(): Inserting information into the DB. load(): Loading specific ID from the DB. loadMultiple(): Loading couple or all the items from the DB(when no IDs was passed). update(): Update a given object in the DB. The passed object must contain the ID of the entry. delete(): Deleting a specific item form the DB. deleteMultiple(): Similar to loadMultiple but for deleting - if not IDs was passed then deleting all the entries in the table.","tags":"","url":"The_DB_layer\/Writing_a_custom_driver\/Storage.html"},{"title":"Managers","text":"Get the settings: &lt;?php \\Nuntius\\Nuntius::getSettings(); Get the DB layer: &lt;?php \\Nuntius\\Nuntius::getRethinkDB(); Get the entity manager: &lt;?php \\Nuntius\\Nuntius::getEntityManager(); Get the task manager: &lt;?php \\Nuntius\\Nuntius::getTasksManager(); Get the update manager: &lt;?php \\Nuntius\\Nuntius::getUpdateManager();","tags":"","url":"Uncovered_API\/Managers.html"},{"title":"Slack how to","text":"How to send a message to the user: &lt;?php namespace Nuntius\\Plugin; \/** * Class Message. * * Triggered when a message eas sent. *\/ class Message extends NuntiusPluginAbstract { \/** * {@inheritdoc} *\/ public function action() { $this-&gt;client-&gt;getDMByUserId('USER_ID')-&gt;then(function (ChannelInterface $channel) { $this-&gt;client-&gt;send('Hi user!', $channel); }); } } Send message in a room: &lt;?php namespace Nuntius\\Plugin; \/** * Class Message. * * Triggered when a message eas sent. *\/ class Message extends NuntiusPluginAbstract { \/** * {@inheritdoc} *\/ public function action() { $this-&gt;client-&gt;getChannelById('ROOM_ID')-&gt;then(function (ChannelInterface $channel) { $this-&gt;client-&gt;send('Hi there room members', $channel); }); } } Send a message to a user when outside a room context AKA HTTP RPC-style: &lt;?php $slack_http = new SlackHttpService(); $slack = $slack_http-&gt;setAccessToken(Nuntius::getSettings()-&gt;getSetting('access_token')); $im_room = $slack-&gt;Im()-&gt;getImForUser($slack-&gt;Users()-&gt;getUserByName(strtolower($info['username']))); $message = new SlackHttpPayloadServicePostMessage(); $message -&gt;setChannel($im_room) -&gt;setText($info['text']); \/\/ Posting the message. $slack-&gt;Chat()-&gt;postMessage($message); For more options look on \\Nuntius\\Examples\\GitHubOpened\\NuntiusGitHubOpenedExample::postMessage","tags":"","url":"Uncovered_API\/Slack_how_to.html"},{"title":"Tests","text":"In order to test GitHub webhooks set the local env variable NUNTIUS_BASE_URL to the address of your nuntius installation: export NUNTIUS_BASE_URL=http:\/\/localhost:8888 After that fire up the test server: php -S localhost:8888 Running tests is easy: bash tests.sh","tags":"","url":"Tests.html"}]}