{"pages":[{"title":"Nnutius documentation","text":"Bots? Bot's is now the hot thing along side VR. You may think about bots as an AI entity sitting on the cloud and runs a neural network for knowing any thing about your users. In reality - it's far away from that. Bot's are much versatile: Slack bot for your team and automate stuff or monitoring events relate to your clients or your infrastructure and send you information on the various rooms. A Facebook Messenger bot which helps users get information from your site quickly or about events relate to the site. Buy products with buttons through the known text interface. Bot's won't replace a site or an application but will be an extra communication path. Slack integration So you understood the need for creating a bot. You looked for a good Slack library that will make it easy but you could not find any. You are right! most of the slack integration are very raw and this is where Nuntius comes to the rescue. Nuntius will integrate with RTM events and give you real time response for slack events, any events, and with easy API you could implement a task base on the user messages. In addition to that you'll get: Entities to store data in the DB Update mechanism to change stuff in the DB after you deployed your bot CLI commands for install and running updates Web hooks integrations(fully customizable) Cron tasks. Facebook Messenger TBD","tags":"","url":"index.html"},{"title":"Nuntius Slack Bot","text":"Gizra became a company when a lot of the employees are remote: USA, Canada, Spain and the list goes on. That status required from us to start using Slack. But the problem is that we wanted Slack to be cool. The obvious idea is to have a bot. The bot will interact with us and might improve the way we communicate. Origin Like any awesome superhero, Nuntius have an origin story. It's not a tragic origin story when his uncle-CPU died due to lack of understanding that with great power comes great responsibility. Nuntius in Latin means messages. That was the original project - a chat based on any backend technology: Drupal, Wordpress, NodeJS, etc., etc. that could connect to any front end technology(React, Elm, Angular, etc., etc.) and using any WebSocket service(Socket.IO, Pusher, FireBase). The project was too much for a single man but the name lived on. Set up. You'll need PHP 5.6 and above, Composer and RethinkDB. After creating a bot, Go to https:\/\/YOURTEAM.slack.com\/apps. Click on Manage and under Custom integration you'll see your bot. Click on the bot to get the access token. cp settings.local.example.yml settings.local.yml composer install rethinkdb Open the settings file you created and set the token you copied, and run: php console.php nuntius:install php bot.php That's it. Nuntius is up and running. Integrating Integration can be done through the main settings.yml file(or in case you forked the project through the settings.local.yml). The settings.local.yml file will override the settings of the settings.yml file. Let's go through the various integrations.","tags":"","url":"Nuntius_Slack_Bot.html"},{"title":"Events","text":"Integration with slack can be achieved in various ways. Nuntius implementing the integration via WebSocket and push events AKA RTM events. For any operation on slack, there is a matching RTM event. You can look on the list here. Let's see how to interact with the message events. In the settings.yml we have the events section: events: presence_change: '\\Nuntius\\Plugin\\PresenceChange' message: '\\Nuntius\\Plugin\\Message' The message key paired with the namespace for the class that needs to implement the logic for the events. Let's have a look at the code: &lt;?php namespace Nuntius\\Plugin; \/** * Class Message. * * Triggered when a message eas sent. *\/ class Message extends NuntiusPluginAbstract { \/** * {@inheritdoc} *\/ public function action() { \/\/ code here... } } Every time someone will send a message the action method will be invoked. On presence change For now, until we will switch to Symfony event dispatcher, events can response to presence change, AKA when the user logged out or in. We use that option to notify the users for the reminders. Let's look on how the message: &lt;?php namespace Nuntius\\Plugin; \/** * Class Message. * * Triggered when a message eas sent. *\/ class Message extends NuntiusPluginAbstract { \/** * {@inheritdoc} *\/ public function actOnPresenceChange() { if ($this-&gt;data['presence'] == 'away') { return; } $rows = $this-&gt;db -&gt;getTable('reminders') -&gt;filter(\\r\\row('user')-&gt;eq($this-&gt;data['user'])) -&gt;run($this-&gt;db-&gt;getConnection()); foreach ($rows as $row) { $result = $row-&gt;getArrayCopy(); $this-&gt;client-&gt;getDMByUserId($result['user'])-&gt;then(function (DirectMessageChannel $channel) use ($result) { \/\/ Send the reminder. $text = 'Hi! You asked me to remind you: ' . $result['reminder']; $this-&gt;client-&gt;send($text, $channel); \/\/ Delete the reminder from the DB. $this-&gt;reminders-&gt;delete($result['id']); }); } } } In this case, we are looking for reminders which the user set and send it as a private message.","tags":"","url":"Events.html"},{"title":"Entities","text":"At some point you might want to keep stuff in the DB. The database is based on Rethinkdb. Similar to event integration definition, entity defined in the settings.yml file: entities: reminders: '\\Nuntius\\Entity\\Reminders' context: '\\Nuntius\\Entity\\Context' context_archive: '\\Nuntius\\Entity\\RunningContext' running_context: '\\Nuntius\\Entity\\RunningContext' system: '\\Nuntius\\Entity\\System' You could implement methods relate to the entity in the matching class but you will see that the basic methods are enough. Add an entry &lt;?php \\Nuntius\\Nuntius::getEntityManager() -&gt;get('context') -&gt;insert(['foo' =&gt; 'bar']); Load an entry &lt;?php \\Nuntius\\Nuntius::getEntityManager() -&gt;get('context') -&gt;load(ID); Load all the entries &lt;?php \\Nuntius\\Nuntius::getEntityManager() -&gt;get('context') -&gt;loadAll(); Update an entry &lt;?php \\Nuntius\\Nuntius::getEntityManager() -&gt;get('context') -&gt;update(ID, ['foo' =&gt; 'bar']); Delete an entry &lt;?php \\Nuntius\\Nuntius::getEntityManager() -&gt;get('context') -&gt;delete(ID); Query in the DB Except for the CRUD layer, sometimes you need to look for items. Have a look at the code: &lt;?php \\Nuntius\\Nuntius::getRethinkDB() -&gt;getTable('running_context') -&gt;filter(\\r\\row('foo')-&gt;eq('bar')) -&gt;filter(\\r\\row('bar')-&gt;ne('fo')) -&gt;run($this-&gt;db-&gt;getConnection()) -&gt;toArray();","tags":"","url":"Entities.html"},{"title":"Tasks","text":"One way to communicate with Nuntius is via text. First, let's have a look at the settings.yml file: tasks: reminders: '\\Nuntius\\Tasks\\Reminders' help: '\\Nuntius\\Tasks\\Help' introduction: '\\Nuntius\\Tasks\\Introduction' The tasks plugin needs to declare to which text it needs to response AKA scope: There two types of plugins: Black box task - A task that needs arguments, or not, and does a simple job: set a reminder for later. Conversation task - A task which depends on information and can get it by asking the user a couple of questions. Each conversation task has a conversation scope: Forever - a scope that likely won't change in the near future: List of the user's team members. Temporary - A scope that we don't need to keep forever: What you want to eat for lunch. But a temporary scope may not be relevant forever but we might want to use in the future. We would likely want to keep the places the user invited food from so we could suggest that in the past. Let's dive into the code. Black box task &lt;?php namespace Nuntius\\Tasks; \/** * Remind to the user something to do. *\/ class Reminders extends TaskBaseAbstract implements TaskBaseInterface { \/** * {@inheritdoc} *\/ public function scope() { return [ '\/remind me (.*)\/' =&gt; [ 'human_command' =&gt; 'remind me REMINDER', 'description' =&gt; 'Next time you log in I will remind you what you ' . ' wrote in the REMINDER', 'callback' =&gt; 'addReminder', ], ]; } \/** * Adding a reminder to the DB. * * @param string $reminder * The reminder of the user. * * @return string * You got it dude! *\/ public function addReminder($reminder) { $this-&gt;entityManager-&gt;get('reminders')-&gt;insert([ 'reminder' =&gt; $reminder, 'user' =&gt; $this-&gt;data['user'], ]); return 'OK! I got you covered!'; } } In the method scope we define to which text we need to respond. Each (.*) is an argument. The keys meaning are: human_command: An example of how user input should be. description: Describing what the command will do. callback: The callback which will be invoked with the argument you expect to receive. Conversation task Let's look first at the code and explain how to write the plugin: &lt;?php namespace Nuntius\\Tasks; \/** * Remind to the user something to do. *\/ class Introduction extends TaskConversationAbstract implements TaskConversationInterface { \/** * {@inheritdoc} *\/ public function scope() { return [ '\/nice to meet you\/' =&gt; [ 'human_command' =&gt; 'nice to meet you', 'description' =&gt; 'We will do a proper introduction', ], ]; } \/** * {@inheritdoc} *\/ public function conversationScope() { return 'forever'; } \/** * Get the user first name. *\/ public function questionFirstName() { return 'Oh hey! It looks that we are not introduced yet. what is your first name?'; } \/** * Get the last name of the user. *\/ public function questionLastName() { return 'what is your last name?'; } \/** * {@inheritdoc} *\/ public function collectAllAnswers() { return 'Well, ' . $this-&gt;answers['FirstName'] . ' ' . $this-&gt;answers['LastName'] . ', it is a pleasure.'; } } First, it's important to implement the TaskConversationInterface interface. This is the way we recognize this a conversation task. Similar to the black box task we do define a scope but in this case, we don't define a callback. That's because nuntius will ask the question by a naming conventions method: methods with a question prefix will be invoked(similar to Unit test). The method needs to return the text of the question. The questions will be triggered by the order in the class - so keep in a rational order of methods. When nuntius collected all the answers, the collectAllAnswers will be invoked. The answers will be available in the answers property with the matching name of the method which holds the question but without the question prefix. In case something got in the way and the user lost his internet connection or the server went down the answers won't get lost. The answers stored in the DB except for a temporary context conversation. The answers will move into an archive and won't be available for next time the conversation will start.","tags":"","url":"Tasks.html"},{"title":"Updates","text":"You deployed nuntius and you added some functionality but that functionality needs some new entities tables, maybe change some information about the user etc. etc. For that case, we have the updates mechanism. Implementing a new update: updates: 1: '\\Nuntius\\Update\\Update1' The code look pretty obvious: &lt;?php namespace Nuntius\\Update; class Update1 implements UpdateBaseInterface { \/** * Describe what the update going to do. * * @return string * What the update going to do. *\/ public function description() { return 'Example update'; } \/** * Running the update. * * @return string * A message for what the update did. *\/ public function update() { return 'You run a simple update. Nothing happens but this update will not run again.'; } } About the methods: description: explain what the update is going to do. update: Preform the update. The text the function will return will show after the update was invoked successfully. A couple of rules: Updates that invoked before won't invoked again. The update will be invoked in the order in the yml file. When installing nuntius, all the listed updates will be marked as updates which invoked already.","tags":"","url":"Updates.html"},{"title":"Commands","text":"Commands are an easy way to add CLI integration. The commands based on the Symfony console component so we won't go and explain the API. You can read about it here Let's have a look on how to define: commands: - '\\Nuntius\\Commands\\UpdateCommand' - '\\Nuntius\\Commands\\InstallCommand' Let's have a look at the code that installs Nuntius for us: &lt;?php namespace Nuntius\\Commands; class InstallCommand extends Command { \/** * {@inheritdoc} *\/ protected function configure() { $this -&gt;setName('nuntius:install') -&gt;setDescription('Install nuntius') -&gt;setHelp('Set up nuntius'); } \/** * {@inheritdoc} *\/ protected function execute(InputInterface $input, OutputInterface $output) { $io = new SymfonyStyle($input, $output); $value = Nuntius::getSettings(); $db = Nuntius::getRethinkDB(); $io-&gt;section(&quot;Setting up the DB.&quot;); $db-&gt;createDB($value['rethinkdb']['db']); $io-&gt;success(&quot;The DB was created&quot;); sleep(5); $io-&gt;section(&quot;Creating entities tables.&quot;); foreach (array_keys($value['entities']) as $scheme) { $db-&gt;createTable($scheme); $io-&gt;success(&quot;The table {$scheme} has created&quot;); } \/\/ Run this again. $db-&gt;getTable('system')-&gt;insert(['id' =&gt; 'updates', 'processed' =&gt; []])-&gt;run($db-&gt;getConnection()); Nuntius::getEntityManager()-&gt;get('system')-&gt;update('updates', ['processed' =&gt; array_keys(Nuntius::getUpdateManager()-&gt;getUpdates())]); $io-&gt;section(&quot;The install has completed.&quot;); $io-&gt;text('run php bot.php'); } }","tags":"","url":"Commands.html"},{"title":"Webhooks integration","text":"Github Yes, there are a lot of slack integrations but most of them pretty generic. They don't provide a real feedback from the bot - bad information in the PR or incorrect information in the issue body. Let's have a look on how to set the integration: webhooks: github: opened: '\\Nuntius\\Webhooks\\GitHub\\Opened' Now, let's have a look at the code: &lt;?php \/** * Acting upon issue or pull request opening. *\/ class Opened extends GitHubWebhooksAbstract implements GitHubWebhooksInterface { \/** * {@inheritdoc} *\/ public function act() { $payload = $this-&gt;data; $key = !empty($payload-&gt;pull_request) ? 'pull_request' : 'issue'; $payload = [ 'event' =&gt; 'open', 'type' =&gt; $key, 'user' =&gt; $payload-&gt;{$key}-&gt;user-&gt;login, 'title' =&gt; $payload-&gt;{$key}-&gt;title, 'body' =&gt; $payload-&gt;{$key}-&gt;body, ]; $this-&gt;logger-&gt;insert([ 'logging' =&gt; 'opened_' . $key, 'payload' =&gt; $payload, ]); } } For now, there is just a logging event. After adding Symfony event dispatcher, you could write a better integration. Post act You can add a logic to the controller that will act after the act method was triggered. That's more suitable for logging stuff rather than implementing a logic: &lt;?php abstract class GitHubWebhooksAbstract implements GitHubWebhooksInterface { \/\/\/ ... \/** * {@inheritdoc} *\/ public function postAct() { $this-&gt;logger-&gt;insert((array) $this-&gt;getData()); } }","tags":"","url":"Webhooks_integration.html"},{"title":"Services","text":"All the managers(will be covered below) defined as Symfony services. In a nutshell, a service is a class which implement a logic and can receive other services as an argument and can be injected to other services as well. For more info go to the DependencyInjection Component documentation. You can add as many services as you'd like to. As always, let's have a look at the settings.yml file: services: - 'services.local.yml' By default, you can add services in the services.local.yml but if you want to manage that in other files you can add them in the settings.local.yml file.","tags":"","url":"Services.html"},{"title":"Cron tasks","text":"If you need to run command in a constant period of time such as: sending messages in specific hours, process a lot of data in the DB, you need cron tasks. To enable the cron task you can add in the cront task the next code: *\/1 * * * * PATH_TO_PHP PATH_TO_NUNTIUS\/cron.php &gt;\/dev\/null 2&gt;&amp;1 If you see that the cron task is not triggered, try to give 777 permission to the file. The cron task will be fired each minutes but that should not bother you. Let's have a look on the code. First, the settings.yml file: cron: log: '\\Nuntius\\Cron\\LogThings' Next, let's look on how to define the cron job: &lt;?php namespace Nuntius\\Cron; class LogThings extends CronTaskAbstract implements CronTaskInterface { \/** * {@inheritdoc} *\/ protected $period = '*\/5 * * * *'; \/** * {@inheritdoc} *\/ public function run() { \/\/ ... } } The $period property will tell to cron what is the periodic rule it's follows. In this case each five minutes. The next par is the run method. In that method you'll apply the logic of the the task.","tags":"","url":"Cron_tasks.html"},{"title":"Managers","text":"Get the settings: &lt;?php \\Nuntius\\Nuntius::getSettings(); Get the DB layer: &lt;?php \\Nuntius\\Nuntius::getRethinkDB(); Get the entity manager: &lt;?php \\Nuntius\\Nuntius::getEntityManager(); Get the task manager: &lt;?php \\Nuntius\\Nuntius::getTasksManager(); Get the update manager: &lt;?php \\Nuntius\\Nuntius::getUpdateManager();","tags":"","url":"Uncovered_API\/Managers.html"},{"title":"Slack how to","text":"How to send a message to the user: &lt;?php namespace Nuntius\\Plugin; \/** * Class Message. * * Triggered when a message eas sent. *\/ class Message extends NuntiusPluginAbstract { \/** * {@inheritdoc} *\/ public function action() { $this-&gt;client-&gt;getDMByUserId('USER_ID')-&gt;then(function (ChannelInterface $channel) { $this-&gt;client-&gt;send('Hi user!', $channel); }); } } Send message in a room: &lt;?php namespace Nuntius\\Plugin; \/** * Class Message. * * Triggered when a message eas sent. *\/ class Message extends NuntiusPluginAbstract { \/** * {@inheritdoc} *\/ public function action() { $this-&gt;client-&gt;getChannelById('ROOM_ID')-&gt;then(function (ChannelInterface $channel) { $this-&gt;client-&gt;send('Hi there room members', $channel); }); } } Send a message to a user when outside a room context AKA HTTP RPC-style: &lt;?php $slack_http = new SlackHttpService(); $slack = $slack_http-&gt;setAccessToken(Nuntius::getSettings()-&gt;getSetting('access_token')); $im_room = $slack-&gt;Im()-&gt;getImForUser($slack-&gt;Users()-&gt;getUserByName(strtolower($info['username']))); $message = new SlackHttpPayloadServicePostMessage(); $message -&gt;setChannel($im_room) -&gt;setText($info['text']); \/\/ Posting the message. $slack-&gt;Chat()-&gt;postMessage($message); For more options look on \\Nuntius\\Examples\\GitHubOpened\\NuntiusGitHubOpenedExample::postMessage","tags":"","url":"Uncovered_API\/Slack_how_to.html"},{"title":"Tests","text":"In order to test GitHub webhooks set the local env variable NUNTIUS_BASE_URL to the address of your nuntius installation: export NUNTIUS_BASE_URL=http:\/\/localhost:8888 After that fire up the test server: php -S localhost:8888 Running tests is easy: bash tests.sh","tags":"","url":"Tests.html"}]}