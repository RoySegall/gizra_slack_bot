{"pages":[{"title":"Nnutius documentation","text":"Bots? Bots are now the hot thing alongside VR. You may think about bots as an AI entity sitting on the cloud and runs a neural network for knowing any thing about your users. In reality - it's far away from that. Bot are much versatile: Slack bot for your team and automate stuff or monitoring events relate to your clients or your infrastructure and send you information on the various rooms. A Facebook Messenger bot which helps users get information from your site quickly or about events relate to the site. Buy products with buttons through the known text interface. Bot won't replace a site or an application but will be an extra communication path. Slack integration So you understood the need for creating a bot. You looked for a good Slack library that will make it easy but you could not find any. You are right! most of the slack integration are very raw and this is where Nuntius comes to the rescue. Nuntius will integrate with RTM events and give you real-time response for slack events, any events, and with easy API you could implement a task base on the user messages. In addition to that you'll get: Entities to store data in the DB Update mechanism to change stuff in the DB after you deployed your bot CLI commands for install and running updates Webhooks integrations(fully customizable) Cron tasks. Facebook Messenger Yes. The Messenger platform is based on webhooks. Nuntius is not an opinionated framework - you need to set up the bot in the Facebook developer platform. Implementing feedback is also elaborated. Twitter TBD","tags":"","url":"index.html"},{"title":"Nuntius Slack Bot","text":"Gizra became a company when a lot of the employees are remote: USA, Canada, Spain and the list goes on. That status required from us to start using Slack. But the problem is that we wanted Slack to be cool. The obvious idea is to have a bot. The bot will interact with us and might improve the way we communicate. Origin Like any awesome superhero, Nuntius have an origin story. It's not a tragic origin story when his uncle-CPU died due to lack of understanding that with great power comes great responsibility. Nuntius in Latin means messages. That was the original project - a chat based on any backend technology: Drupal, Wordpress, NodeJS, etc., etc. that could connect to any front end technology(React, Elm, Angular, etc., etc.) and using any WebSocket service(Socket.IO, Pusher, FireBase). The project was too much for a single man but the name lived on. Set up. You'll need PHP 5.6 and above, Composer and RethinkDB. After creating a bot, Go to https:\/\/YOURTEAM.slack.com\/apps. Click on Manage and under Custom integration you'll see your bot. Click on the bot to get the access token. Install composer components and start RethinkDB: composer install rethinkdb Let's start and run the installe: php console.php nuntius:install After that will finish you need to run php console.php nuntius:run That's it. Nuntius is up and running. Integrating Nuntius integrations is done through the hooks.yml file. All the events, entities, tasks and other features(you will soon see) are listed in hooks.yml. In case you forked the project, and that the reasonable scenario, you need to create a hooks.local.yml in the settings directory. The hooks.local.yml allow you to override the definitions in hooks.yml thus gives you the option to swap everything in the system.","tags":"","url":"Nuntius_Slack_Bot.html"},{"title":"Events","text":"Integration with slack can be achieved in various ways. Nuntius implementing the integration via WebSocket and push events AKA RTM events. For any operation on slack, there is a matching RTM event. You can look on the list here. Let's see how to interact with the message events. In the hooks.yml we have the events section: events: presence_change: '\\Nuntius\\Plugin\\PresenceChange' message: '\\Nuntius\\Plugin\\Message' The message key paired with the namespace for the class that needs to implement the logic for the events. Let's have a look at the code: &lt;?php namespace Nuntius\\Plugin; \/** * Class Message. * * Triggered when a message eas sent. *\/ class Message extends NuntiusPluginAbstract { \/** * {@inheritdoc} *\/ public function action() { \/\/ code here... } } Every time someone will send a message the action method will be invoked. On presence change For now, until we will switch to Symfony event dispatcher, events can response to presence change, AKA when the user logged out or in. We use that option to notify the users for the reminders. Let's look on how the message: &lt;?php namespace Nuntius\\Plugin; \/** * Remind to the user something to do. *\/ class Reminders extends TaskBaseAbstract implements TaskBaseInterface { \/** * {@inheritdoc} *\/ public function actOnPresenceChange() { if ($this-&gt;data['presence'] == 'away') { return; } $rows = $this-&gt;query -&gt;table('reminders') -&gt;condition('user', $this-&gt;data['user']) -&gt;execute(); foreach ($rows as $row) { $this-&gt;client-&gt;getDMByUserId($row['user'])-&gt;then(function (DirectMessageChannel $channel) use ($row) { \/\/ Send the reminder. $text = 'Hi! You asked me to remind you: ' . $row['reminder']; $this-&gt;client-&gt;send($text, $channel); \/\/ Delete the reminder from the DB. $this-&gt;reminders-&gt;delete($row['id']); }); } } } In this case, we are looking for reminders which the user set and send it as a private message.","tags":"","url":"Events.html"},{"title":"Entities","text":"At some point you might want to keep stuff in the DB. The database is based on Rethinkdb. Similar to event integration definition, entity defined in the hooks.yml file: entities: reminders: '\\Nuntius\\Entity\\Reminders' context: '\\Nuntius\\Entity\\Context' context_archive: '\\Nuntius\\Entity\\RunningContext' running_context: '\\Nuntius\\Entity\\RunningContext' system: '\\Nuntius\\Entity\\System' You could implement methods relate to the entity in the matching class but you will see that the basic methods are enough. Add an entry &lt;?php \\Nuntius\\Nuntius::getEntityManager() -&gt;get('context') -&gt;insert(['foo' =&gt; 'bar']); Load an entry &lt;?php \\Nuntius\\Nuntius::getEntityManager() -&gt;get('context') -&gt;load(ID); Load multiple entries You can ask for all of them: &lt;?php \\Nuntius\\Nuntius::getEntityManager() -&gt;get('context') -&gt;loadMultiple(); Or you can ask for multiple entities: &lt;?php \\Nuntius\\Nuntius::getEntityManager() -&gt;get('context') -&gt;loadMultiple(['id1', 'id2', 'id3']); Update an entry &lt;?php \\Nuntius\\Nuntius::getEntityManager() -&gt;get('context') -&gt;update(['id' =&gt; 'ID', 'foo' =&gt; 'bar']); Delete from the DB You can delete a single entity: &lt;?php \\Nuntius\\Nuntius::getEntityManager() -&gt;get('context') -&gt;delete('id'); You can multiple entities: &lt;?php \\Nuntius\\Nuntius::getEntityManager() -&gt;get('context') -&gt;deleteMultiple(['id1', 'id2', 'id3']); Or you can delete all the entities: &lt;?php \\Nuntius\\Nuntius::getEntityManager() -&gt;get('context') -&gt;deleteMultiple();","tags":"","url":"Entities.html"},{"title":"Multiple bots and context manager","text":"Nuntius is very slack oriented since this is the first platform it was designed for. But, Slack is not the only bot platform and as a framework for bots, Nuntius need to support all platforms. And it is. Where are you? Requests can come from a lot of platforms and in order to know how to select the correct callback we need first to know which platform looked for the matching task to the text. For that we have the context manager. It's service designed to keep one variable through the page request - which platform looked for the matching task to the text. It's very easy to use it: &lt;?php \\Nuntius\\Nuntius::getContextManager()-&gt;setContext(PLATFORM); You'll need to set the context before triggering looking for matching text, just like facebook in \\Nuntius\\WebhooksRounting\\Facebook::response: &lt;?php if (!empty($_GET['hub_challenge'])) { \/\/ Validating facebook testing request. return new Response($_GET['hub_challenge']); } Nuntius::getContextManager()-&gt;setContext('facebook'); $this-&gt;fbRequest = $this-&gt;extractFacebookRequest(json_decode(file_get_contents(&quot;php:\/\/input&quot;))); $this-&gt;accessToken = Nuntius::getSettings()-&gt;getSetting('fb_token'); $this-&gt;sendAPI -&gt;setRecipientId($this-&gt;fbRequest['sender']) -&gt;setAccessToken($this-&gt;accessToken); if (empty($this-&gt;fbRequest['text'])) { if (!empty($this-&gt;fbRequest['postback'])) { $this-&gt;sendAPI-&gt;sendMessage($this-&gt;helpRouter()); } return new Response(); } $task_info = Nuntius::getTasksManager()-&gt;getMatchingTask($this-&gt;fbRequest['text']); If you want to know the current context just use: &lt;?php \\Nuntius\\Nuntius::getContextManager()-&gt;getContext(); And that's it.","tags":"","url":"Multiple_bots_and_context_manager.html"},{"title":"introduction","text":"One way to communicate with Nuntius is via text. First, let's have a look at the hooks.yml file: tasks: reminders: '\\Nuntius\\Tasks\\Reminders' help: '\\Nuntius\\Tasks\\Help' introduction: '\\Nuntius\\Tasks\\Introduction' The tasks plugin needs to declare to which text it needs to response AKA scope: There two types of plugins: Black box task - A task that needs arguments, or not, and does a simple job: set a reminder for later. Conversation task - A task which depends on information and can get it by asking the user a couple of questions. Each conversation task has a conversation scope: Forever - a scope that likely won't change in the near future: List of the user's team members. Temporary - A scope that we don't need to keep forever: What you want to eat for lunch. But a temporary scope may not be relevant forever but we might want to use in the future. We would likely want to keep the places the user invited food from so we could suggest that in the past.","tags":"","url":"Tasks\/introduction.html"},{"title":"Black box task","text":"&lt;?php namespace Nuntius\\Tasks; \/** * Remind to the user something to do. *\/ class Reminders extends TaskBaseAbstract implements TaskBaseInterface { \/** * {@inheritdoc} *\/ public function scope() { return [ '\/remind me (.*)\/' =&gt; [ 'human_command' =&gt; 'remind me REMINDER', 'description' =&gt; 'Next time you log in I will remind you what you ' . ' wrote in the REMINDER', 'callback' =&gt; 'addReminder', ], ]; } \/** * Adding a reminder to the DB. * * @param string $reminder * The reminder of the user. * * @return string * You got it dude! *\/ public function addReminder($reminder) { $this-&gt;reminders-&gt;save([ 'reminder' =&gt; $reminder, 'user' =&gt; $this-&gt;data['user'], ]); return 'OK! I got you covered!'; } } In the method scope we define to which text we need to respond. Each (.*) is an argument. The keys meaning are: human_command: An example of how user input should be. description: Describing what the command will do. callback: The callback which will be invoked with the argument you expect to receive. Tasks and multiple bots In Multiple bots and context manager we talked on context manager and how we can handle multiple bots. Now, let's see how tasks are being handle in when we have multiple bots. In the section above you can see a command declaration. When the the callback is a string, and the task manager found that the given text from the user match a structure of a task the function will be invoke in any bot platform. The problem is - different platforms have different variables and need different format of the message the user will get. In order to solve that, the callback can be converted into array and will keyed in a structure of platform =&gt; callback. Let's see how the help task solve that: \/** * {@inheritdoc} *\/ public function scope() { return [ '\/help\/' =&gt; [ 'human_command' =&gt; 'help', 'description' =&gt; 'Giving you help', 'callback' =&gt; [ 'slack' =&gt; 'slackListOfScopes', 'facebook' =&gt; 'facebookListOfScopes', ], ], ]; } \/** * Get all the tasks and their scope(except for this one). *\/ public function slackListOfScopes() { $task_manager = Nuntius::getTasksManager(); $text = []; foreach ($task_manager-&gt;getTasks() as $task_id =&gt; $task) { if ($task_id == 'help') { continue; } foreach ($task-&gt;scope() as $scope) { $text[] = '`' . $scope['human_command'] . '`: ' . $scope['description']; } } return implode(&quot;\\n&quot;, $text); } \/** * A Facebook only text. * * Facebook allows to send only 3 buttons - this what we will do. *\/ public function facebookListOfScopes() { $send_api = Nuntius::facebookSendApi(); return $send_api-&gt;templates-&gt;button -&gt;text('hey there! This is the default help response ' . 'You can try this one and override it later on. ' . 'Hope you will get some ideas :)') -&gt;addButton($send_api-&gt;buttons-&gt;postBack-&gt;title('Say something nice')-&gt;payload('something_nice')) -&gt;addButton($send_api-&gt;buttons-&gt;postBack-&gt;reset()-&gt;title(&quot;What's my name?&quot;)-&gt;payload('what_is_my_name')) -&gt;addButton($send_api-&gt;buttons-&gt;postBack-&gt;reset()-&gt;title('Toss a coin?')-&gt;payload('toss_a_coin')); }","tags":"","url":"Tasks\/Black_box_task.html"},{"title":"Conversation task","text":"Let's look first at the code and explain how to write the plugin: &lt;?php namespace Nuntius\\Tasks; \/** * Remind to the user something to do. *\/ class Introduction extends TaskConversationAbstract implements TaskConversationInterface { \/** * {@inheritdoc} *\/ public function scope() { return [ '\/nice to meet you\/' =&gt; [ 'human_command' =&gt; 'nice to meet you', 'description' =&gt; 'We will do a proper introduction', ], ]; } \/** * {@inheritdoc} *\/ public function conversationScope() { return 'forever'; } \/** * Get the user first name. *\/ public function questionFirstName() { return 'Oh hey! It looks that we are not introduced yet. what is your first name?'; } \/** * Get the last name of the user. *\/ public function questionLastName() { return 'what is your last name?'; } \/** * {@inheritdoc} *\/ public function collectAllAnswers() { return 'Well, ' . $this-&gt;answers['FirstName'] . ' ' . $this-&gt;answers['LastName'] . ', it is a pleasure.'; } } First, it's important to implement the TaskConversationInterface interface. This is the way we recognize this a conversation task. Similar to the black box task we do define a scope but in this case, we don't define a callback. That's because nuntius will ask the question by a naming conventions method: methods with a question prefix will be invoked(similar to Unit test). The method needs to return the text of the question. The questions will be triggered by the order in the class - so keep in a rational order of methods. When nuntius collected all the answers, the collectAllAnswers will be invoked. The answers will be available in the answers property with the matching name of the method which holds the question but without the question prefix. In case something got in the way and the user lost his internet connection or the server went down the answers won't get lost. The answers stored in the DB except for a temporary context conversation. The answers will move into an archive and won't be available for next time the conversation will start.","tags":"","url":"Tasks\/Conversation_task.html"},{"title":"Validating user input","text":"When the user is having a conversation with the bot, we need to validate the input. This is valid only for a conversation, and not a black box task, due to the fact that when the task is a black box task you only have a single input but, in a conversation there are multiple steps and we need to make sure the user can't go the next question until the current task input is valid. Adding a constraint to conversation In order for a validating the question input we need to define the constraint on the scope level. Let's look on the restarting tasks task which delete the context of a un-temporary task. The task is implemented at \\Nuntius\\Tasks\\RestartQuestion: \/** * {@inheritdoc} *\/ public function scope() { return [ '\/delete information\/' =&gt; [ 'human_command' =&gt; 'delete information', 'description' =&gt; 'Delete an information', 'constraint' =&gt; '\\Nuntius\\TasksConstraint\\RestartQuestionConstraint', ], ]; } The constraint key define the namespace of class. Validating method will be invoke by a specific pattern. In order to validate the questionStartingAgain method input we need to create a validateStartingAgain. If the method will return TRUE then the input is OK. If the method will return a text the input is bad and the text will be the text that explain why it failed. Let's have a look on the code: \/** * Validate the input of tasks. * * @param $value * The input of the user. * * @return bool|string *\/ public function validateGetTaskId($value) { $tasks = Nuntius::getTasksManager()-&gt;getRestartableTasks(); foreach ($tasks as $task) { if ($task['label'] == $value) { return TRUE; } } return &quot;Hmmm..... it's look like `{$value}` is not a task I know.&quot;; } \/** * Validate the user input the correct text. * * @param string $value * The input of the user. * * @return bool|string *\/ public function validateStartingAgain($value) { if (!in_array($value, ['yes', 'no', 'y', 'n'])) { return 'The answer need to be one of the following: ' . implode(', ' , ['`yes`', '`no`', '`y`', '`n`']); } return TRUE; }","tags":"","url":"Tasks\/Validating_user_input.html"},{"title":"Updates","text":"You deployed nuntius and you added some functionality but that functionality needs some new entities tables, maybe change some information about the user etc. etc. For that case, we have the updates mechanism. Implementing a new update: updates: 1: '\\Nuntius\\Update\\Update1' The code look pretty obvious: &lt;?php namespace Nuntius\\Update; class Update1 implements UpdateBaseInterface { \/** * Describe what the update going to do. * * @return string * What the update going to do. *\/ public function description() { return 'Example update'; } \/** * Running the update. * * @return string * A message for what the update did. *\/ public function update() { return 'You run a simple update. Nothing happens but this update will not run again.'; } } About the methods: description: explain what the update is going to do. update: Preform the update. The text the function will return will show after the update was invoked successfully. A couple of rules: Updates that invoked before won't invoked again. The update will be invoked in the order in the yml file. When installing nuntius, all the listed updates will be marked as updates which invoked already.","tags":"","url":"Updates.html"},{"title":"Commands","text":"Commands are an easy way to add CLI integration. The commands based on the Symfony console component so we won't go and explain the API. You can read about it here Let's have a look on how to define: commands: - '\\Nuntius\\Commands\\UpdateCommand' - '\\Nuntius\\Commands\\InstallCommand' Let's have a look at the code that installs Nuntius for us: &lt;?php namespace Nuntius\\Commands; class InstallCommand extends Command { \/** * {@inheritdoc} *\/ protected function configure() { $this -&gt;setName('nuntius:install') -&gt;setDescription('Install nuntius') -&gt;setHelp('Set up nuntius'); } \/** * {@inheritdoc} *\/ protected function execute(InputInterface $input, OutputInterface $output) { $io = new SymfonyStyle($input, $output); if (!file_exists(__DIR__ . '\/..\/..\/settings\/credentials.local.yml')) { $question = new ConfirmationQuestion('The credentials yml file is missing. Would you like to generate the file?'); if (!$io-&gt;askQuestion($question)) { $io-&gt;block('Well then, you need to create a copy of the file credentials.yml to credentials.local.yml and populate the values. Good luck!'); return; } $this-&gt;generateCredentials($io); } $value = Nuntius::getSettings()-&gt;getSettings(); $operations = Nuntius::getDb()-&gt;getOperations(); $storage = Nuntius::getDb()-&gt;getStorage(); $io-&gt;section(&quot;Setting up the DB.&quot;); if ($operations-&gt;dbExists($value['rethinkdb']['db'])) { $io-&gt;success(&quot;The DB already exists, skipping.&quot;); } else { $operations-&gt;dbCreate($value['rethinkdb']['db']); $io-&gt;success(&quot;The DB was created&quot;); sleep(5); } $io-&gt;section(&quot;Creating entities tables.&quot;); foreach (array_keys($value['entities']) as $table) { if ($operations-&gt;tableExists($table)) { $io-&gt;success(&quot;The table {$table} already exists, skipping.&quot;); } else { $operations-&gt;tableCreate($table); $io-&gt;success(&quot;The table {$table} has created&quot;); } } \/\/ Run this again. $storage-&gt;table('system')-&gt;save(['id' =&gt; 'updates', 'processed' =&gt; array_keys(Nuntius::getUpdateManager()-&gt;getUpdates())]); $io-&gt;section(&quot;The install has completed.&quot;); $io-&gt;text('run php console.php nuntius:run'); } }","tags":"","url":"Commands.html"},{"title":"What is webhook","text":"By Wikipedia, a Webhook is: A webhook in web development is a method of augmenting or altering the behavior of a web page, or web application, with custom callbacks. These callbacks may be maintained, modified, and managed by third-party users and developers who may not necessarily be affiliated with the originating website or application. But, this might not tell you a lot(me either) so I'll give an example. Real life example Let's say you want to know about something that happens at a GitHub repo, a Docker Hub project or maybe you want to listen to event from you logs service? With Webhook you can accomplish that. Basically, A Webhook is an HTTP request, with a data(payload) or without, which sent to your server from external server.","tags":"","url":"Webhooks\/What_is_webhook.html"},{"title":"Adding webhook support","text":"Now that you know what is a Webhook you know that you need to set an endpoint. Before we begin let's clear something - the endpoint for the incoming webhooks does not mean for any thing else rather than getting information from external services. i.e - setting an endpoint to display a list of entities is a bad practice. Adding a routing As always, let's go to the hooks.yml file: webhooks_routing: 'github': '\\Nuntius\\WebhooksRounting\\GitHub' The key of the item, in this case, github, will be the endpoint. i.e: http:\/\/address.com\/github The router controller You set the endpoint, let's see how the controller should look: &lt;?php \/** * Handling incoming webhooks from GitHub. *\/ class GitHub implements WebhooksRoutingControllerInterface { \/** * {@inheritdoc} *\/ public function response(Request $request) { \/\/ Logic here. return new JsonResponse(['type' =&gt; 'success', 'message' =&gt; 'The request has been processed.']); } } The controller need to implement the response method and do the logic over there: Maybe dispatch events, insert something to DB or just send a PM on slack. In this, you can see the controller return a JsonResponse but you can return any Response object. As long as you return an object because: The service that sent the webhook might think the request failed if a 2XX or a 5XX response was return. Symfony will fail the page of a Response type won't returned.","tags":"","url":"Webhooks\/Adding_webhook_support.html"},{"title":"Local wotk with webhooks","text":"If you want to test the integration you'll right you need that your local host will be acessable. The most easy way to do that is with ngrok. ngrok open your localhost with a temporary address. In my case the address will look like http:\/\/66a4cc4d.ngrok.io\/nuntius-bot\/WEBHOOK. If you want to make sure that something happens you can log it to the logger entity: Nuntius::getEntityManager()-&gt;get('logger')-&gt;insert(['foo' =&gt; 'bar']); And then, to make sure something is going in the DB you can use the built in live entity view option: php console.php nuntius:entity logger live_view This will output the next result in the terminal:","tags":"","url":"Webhooks\/Local_wotk_with_webhooks.html"},{"title":"Configure the integration","text":"Before starting to set up the integration make sure you have a page on Facebook. We will begin by setting up a Facebook application. Go to Facebook developers site: After setting up the app we will add a Messenger product set up: The next ste is to generate a token for the page: Save the token in your credentials.local.yml in fb_token key. Now, let set up the address which Facebook will interact with Nuntius. Click on Setup Webhooks: After that a modal will open for you: Couple of things: The address is the address of the facebook webhook handler - https:\/\/b9204872.ngrok.io\/nuntius-bot\/facebook The token is not mandatory, it can be anything. Under Subscription Fields check all the boxes. You'll get this if anything is OK: Now, we need to set up the page as a subscriber to the events we selected: Please note that for now, when this doc been written, you can't change the address of the webhook.","tags":"","url":"Webhooks\/Facebook\/Configure_the_integration.html"},{"title":"How to implement","text":"You set up as you saw in Configure the integration. If you'll write something like Hey or Hello you'll get something like that: But if you'll write help you'll get something like that: Texts and postbacks The example above implemented in two parts. The first is the response to the text. In slack, the help text bring all the tasks which available to the user but the facebook platforms works a bit different - you cannot provide all the tasks as button due to buttons limitation. That's why a different approach was taken - provide 3 button with nice actions. Let's see how the text implemented: \/** * A Facebook only text. * * Facebook allows to send only 3 buttons - this what we will do. *\/ public function facebookListOfScopes() { $send_api = Nuntius::facebookSendApi(); return $send_api-&gt;templates-&gt;button -&gt;text('hey there! This is the default help response ' . 'You can try this one and override it later on. ' . 'Hope you will get some ideas :)') -&gt;addButton($send_api-&gt;buttons-&gt;postBack-&gt;title('Say something nice')-&gt;payload('something_nice')) -&gt;addButton($send_api-&gt;buttons-&gt;postBack-&gt;title(&quot;What's my name?&quot;)-&gt;payload('what_is_my_name')) -&gt;addButton($send_api-&gt;buttons-&gt;postBack-&gt;title('Toss a coin?')-&gt;payload('toss_a_coin')); } What did we got here? A text with post backs buttons. When clicking on a postback button, Facebook will send a webhook with that information. But how can you respond? As always, nuntius got you covered and provide a FB postback manager. The implementation is easy. Let's see how the postbacks implemented in hooks.yml: # List of FB postback handlers. fb_postbacks: 'something_nice': '\\Nuntius\\FacebookPostBacks\\SomethingNice' 'toss_a_coin': '\\Nuntius\\FacebookPostBacks\\TossACoin' 'what_is_my_name': '\\Nuntius\\FacebookPostBacks\\WhatIsMyName' The key is the payload and the value is the namespace of the class. Let's see an example for a class: &lt;?php class SomethingNice extends FacebookPostBackAbstract implements FacebookPostBackInterface { \/** * {@inheritdoc} *\/ public function postBack() { $texts = [ 'You look lovely!', 'Usually you wakes up looking good. Today, you took it to the next level!', 'Hey there POTUS... sorry! thought you are some one else...', ]; shuffle($texts); return reset($texts); } } For more examples, please go to the Drupal use case. What's the API? Sending messages over the Messenger platform is described in the Send API under the Messenger platform. Sending a text is easy but if you'll look on a Templates buttons you'll be confuse and maybe suffer a light vertigo feeling. Don't worry, Nuntius uses the facebook-messenger-send-api which makes your life much easy. For example, in order to send a button templates you'll need to send this complex JSON: { &quot;attachment&quot;:{ &quot;type&quot;:&quot;template&quot;, &quot;payload&quot;:{ &quot;template_type&quot;:&quot;button&quot;, &quot;text&quot;:&quot;What do you want to do next?&quot;, &quot;buttons&quot;:[ { &quot;type&quot;:&quot;web_url&quot;, &quot;url&quot;:&quot;https:\/\/petersapparel.parseapp.com&quot;, &quot;title&quot;:&quot;Show Website&quot; }, { &quot;type&quot;:&quot;postback&quot;, &quot;title&quot;:&quot;Start Chatting&quot;, &quot;payload&quot;:&quot;USER_DEFINED_PAYLOAD&quot; } ] } } } Using the Send API component makes you life easy, have a look on how the help method use it: \/** * A Facebook only text. * * Facebook allows to send only 3 buttons - this what we will do. *\/ public function facebookListOfScopes() { $send_api = Nuntius::facebookSendApi(); return $send_api-&gt;templates-&gt;button -&gt;text('hey there! This is the default help response ' . 'You can try this one and override it later on. ' . 'Hope you will get some ideas :)') -&gt;addButton($send_api-&gt;buttons-&gt;postBack-&gt;title('Say something nice')-&gt;payload('something_nice')) -&gt;addButton($send_api-&gt;buttons-&gt;postBack-&gt;title(&quot;What's my name?&quot;)-&gt;payload('what_is_my_name')) -&gt;addButton($send_api-&gt;buttons-&gt;postBack-&gt;title('Toss a coin?')-&gt;payload('toss_a_coin')); }","tags":"","url":"Webhooks\/Facebook\/How_to_implement.html"},{"title":"Configure the integration","text":"Setting up the configuration is pretty much easy. Go to the repository settings: And now go to the webhooks page: Add a new Webhook: You can set up in the next way: GitHub will send a request to do a sanity check. Just to make sure the address exists.","tags":"","url":"Webhooks\/GitHub\/Configure_the_integration.html"},{"title":"Add events integration","text":"Github Yes, there are a lot of slack integrations but most of them pretty generic. They don't provide a real feedback from the bot - bad information in the PR or incorrect information in the issue body. Let's have a look on how to set the integration: webhooks: github: opened: '\\Nuntius\\Webhooks\\GitHub\\Opened' Now, let's have a look at the code: &lt;?php \/** * Acting upon issue or pull request opening. *\/ class Opened extends GitHubWebhooksAbstract implements GitHubWebhooksInterface { \/** * {@inheritdoc} *\/ public function act() { $payload = $this-&gt;data; $key = !empty($payload-&gt;pull_request) ? 'pull_request' : 'issue'; $payload = [ 'event' =&gt; 'open', 'type' =&gt; $key, 'user' =&gt; $payload-&gt;{$key}-&gt;user-&gt;login, 'title' =&gt; $payload-&gt;{$key}-&gt;title, 'body' =&gt; $payload-&gt;{$key}-&gt;body, ]; $this-&gt;logger-&gt;insert([ 'logging' =&gt; 'opened_' . $key, 'payload' =&gt; $payload, ]); } } For now, there is just a logging event. After adding Symfony event dispatcher, you could write a better integration. Post act You can add a logic to the controller that will act after the act method was triggered. That's more suitable for logging stuff rather than implementing a logic: &lt;?php abstract class GitHubWebhooksAbstract implements GitHubWebhooksInterface { \/\/\/ ... \/** * {@inheritdoc} *\/ public function postAct() { $this-&gt;logger-&gt;save((array) $this-&gt;getData()); } }","tags":"","url":"Webhooks\/GitHub\/Add_events_integration.html"},{"title":"Services","text":"All the managers(will be covered below) defined as Symfony services. In a nutshell, a service is a class which implement a logic and can receive other services as an argument and can be injected to other services as well. For more info go to the DependencyInjection Component documentation. You can add as many services as you'd like to. As always, let's have a look at the hooks.yml file: services: - 'services.local.yml' By default, you can add services in the services.local.yml but if you want to manage that in other files you can add them in the hooks.local.yml file.","tags":"","url":"Services.html"},{"title":"Cron tasks","text":"If you need to run command in a constant period of time such as: sending messages in specific hours, process a lot of data in the DB, you need cron tasks. To enable the cron task you can add in the cront task the next code: *\/1 * * * * PATH_TO_PHP PATH_TO_NUNTIUS\/cron.php &gt;\/dev\/null 2&gt;&amp;1 If you see that the cron task is not triggered, try to give 777 permission to the file. The cron task will be fired each minutes but that should not bother you. Let's have a look on the code. First, the hooks.yml file: cron: log: '\\Nuntius\\Cron\\LogThings' Next, let's look on how to define the cron job: &lt;?php namespace Nuntius\\Cron; class LogThings extends CronTaskAbstract implements CronTaskInterface { \/** * {@inheritdoc} *\/ protected $period = '*\/5 * * * *'; \/** * {@inheritdoc} *\/ public function run() { \/\/ ... } } The $period property will tell to cron what is the periodic rule it's follows. In this case each five minutes. The next par is the run method. In that method you'll apply the logic of the the task.","tags":"","url":"Cron_tasks.html"},{"title":"Intorduction","text":"At the beginning the DB layer was designed to work with only RethinkDB but, one of Nuntius ideas is that 98% of the components are swappable - any one can replace any core components since all of the integration specified in the settings.yml file. So, the DB layer was abstracted and split into four elements(which we will cover in the upcoming parts). Another reason is the on boarding process of new developers which need to know how to talk with RethinkDB. Before the change you would need to do something like: &lt;?php \\Nuntius\\Nuntius::getRethinkDB() -&gt;getTable('running_context') -&gt;filter(\\r\\row('foo')-&gt;eq('bar')) -&gt;filter(\\r\\row('bar')-&gt;ne('fo')) -&gt;run($this-&gt;db-&gt;getConnection()) -&gt;toArray(); Not very nice and intuitive. After the abstraction you need to do: &lt;?php \\Nuntius\\Nuntius::getDb() -&gt;getQuery() -&gt;table('running_context') -&gt;condition('foo', 'bar') -&gt;condition('bar', 'fo') -&gt;execute(); Much better. Go Deep into the rabbit hole part to see the available methods and what you can do.","tags":"","url":"The_DB_layer\/Intorduction.html"},{"title":"Deep into the rabbit hole","text":"As most of the API in Nuntius, the DB layer is accessible using a service. Three ways are defined as best practice: First, aliasing from Nuntius static methods: &lt;?php \\Nuntius\\Nuntius::getDb(); The second is just calling the service: &lt;?php \\Nuntius\\Nuntius::container()-&gt;get('db'); The third one is the best one when writing a service: services: manager.entity: class: \\Nuntius\\EntityManager arguments: ['@db', '@config'] And you service should look like: &lt;?php namespace Nuntius; use Nuntius\\Db\\DbDispatcher; \/** * Entity mananger. *\/ class EntityManager { function __construct(DbDispatcher $db, NuntiusConfig $config) { $this-&gt;db = $db; } \/\/\/ ... } Know you your methods The \\Nuntius\\Nuntius::getDb(); will get give you access to couple of methods: Nuntius::getDb()-&gt;getQuery(): The query part, which you know for the previous page, which allow you to query the DB and get arrays of rows match your query. Nuntius::getDb()-&gt;getStorage(): CRUD(Create, Read, Update, Delete) operation on the table in the DB. Nuntius::getDb()-&gt;getOperations(): Creating and delete databases, tables and indexes(very hard core!). Nuntius::getDb()-&gt;getMetadata(): Get information about the DB: the type, description and text when the user will install Nuntius. More information will be provided in the Writing a custom driver part.","tags":"","url":"The_DB_layer\/Deep_into_the_rabbit_hole.html"},{"title":"Writing a custom driver","text":"Writing a custom DB driver comes for one reason only: you love a DB. That DB is part of your daily stack and you don't want to to start using another DB. That's OK. As any integration, we will start with the hooks.yml file. Let's see how we added rethinkdb into the db_drivers: db_drivers: rethinkdb: metadata: '\\Nuntius\\Db\\RethinkDB\\RethinkDbMetadataHandler' operations: '\\Nuntius\\Db\\RethinkDB\\RethinkDbOperationHandler' query: '\\Nuntius\\Db\\RethinkDB\\RethinkDbQueryHandler' storage: '\\Nuntius\\Db\\RethinkDB\\RethinkDbStorageHandler' The order of the items is not mandatory but could be much more easy to implement in that order.","tags":"","url":"The_DB_layer\/Writing_a_custom_driver\/Writing_a_custom_driver.html"},{"title":"Metadata","text":"The metadata part will describe the DB and what it can do. Let's take a look on RethinkDB: &lt;?php \/** * RethinkDB metadata handler. *\/ class RethinkDbMetadataHandler implements DbMetadataHandlerInterface { \/** * {@inheritdoc} *\/ public function dbType() { return 'NoSQL'; } \/** * {@inheritdoc} *\/ public function installerDescription() { return 'No SQL light weight DB with real time support.'; } \/** * {@inheritdoc} *\/ public function supportRealTime() { return TRUE; } } dbType(): What the DB type: A NoSQL or SQL. installerDescription(): Small description on the DB. It will appear in the installation and provide to the user information about the DB and why the choose the DB as the daily driver. supportRealTime(): One of nuntius commands allows you to see live changes in a table. For the command to work, the DB metadata need to tell if the DB support real time or not.","tags":"","url":"The_DB_layer\/Writing_a_custom_driver\/Metadata.html"},{"title":"Operation","text":"The operation part is the one of the hard core parts in the driver; It's suppose to handle creation and deletion of databases, tables and indexes: &lt;?php namespace Nuntius\\Db\\RethinkDB; use Nuntius\\Db\\DbOperationHandlerInterface; use Nuntius\\Nuntius; \/** * RethinkDB operation handler. *\/ class RethinkDbOperationHandler implements DbOperationHandlerInterface { \/** * The rethinkDB service. * * @var \\Nuntius\\NuntiusRethinkdb *\/ protected $rethinkDB; \/** * The connection object. * * @var \\r\\Connection *\/ protected $connection; \/** * The DB name. * * @var string *\/ protected $db; \/** * Constructing. *\/ function __construct() { $this-&gt;rethinkDB = @Nuntius::getRethinkDB(); $this-&gt;connection = $this-&gt;rethinkDB-&gt;getConnection(); $this-&gt;db = Nuntius::getSettings()-&gt;getSetting('rethinkdb')['db']; } \/** * {@inheritdoc} *\/ public function connected() { return $this-&gt;connection; } \/** * {@inheritdoc} *\/ public function getError() { return $this-&gt;rethinkDB-&gt;error; } \/** * {@inheritdoc} *\/ public function dbCreate($db) { \\r\\dbCreate($db)-&gt;run($this-&gt;connection); return $this; } \/** * {@inheritdoc} *\/ public function dbDrop($db) { \\r\\dbDrop($db)-&gt;run($this-&gt;connection); return $this; } \/** * {@inheritdoc} *\/ public function dbList() { return \\r\\dbList()-&gt;run($this-&gt;connection); } \/** * {@inheritdoc} *\/ public function dbExists($db) { return in_array($db, $this-&gt;dbList()); } \/** * {@inheritdoc} *\/ public function tableCreate($table) { \\r\\db($this-&gt;db)-&gt;tableCreate($table)-&gt;run($this-&gt;connection); return $this; } \/** * {@inheritdoc} *\/ public function tableDrop($table) { \\r\\db($this-&gt;db)-&gt;tableDrop($table)-&gt;run($this-&gt;connection); return $this; } \/** * {@inheritdoc} *\/ public function tableList() { return \\r\\db($this-&gt;db)-&gt;tableList()-&gt;run($this-&gt;connection); } \/** * {@inheritdoc} *\/ public function tableExists($table) { return in_array($table, $this-&gt;tableList()); } \/** * {@inheritdoc} *\/ public function indexCreate($table, $column) { \\r\\db($this-&gt;db)-&gt;table($table)-&gt;indexCreate($column)-&gt;run($this-&gt;connection); return $this; } \/** * {@inheritdoc} *\/ public function indexDrop($table, $column) { \\r\\db($this-&gt;db)-&gt;table($table)-&gt;indexDrop($column)-&gt;run($this-&gt;connection); return $this; } \/** * {@inheritdoc} *\/ public function indexList($table) { return \\r\\db($this-&gt;db)-&gt;table($table)-&gt;indexList()-&gt;run($this-&gt;connection); } \/** * Making sure the index exists in a table. * * @param $table * The table name. * @param $column * The columns name. * * @return bool *\/ public function indexExists($table, $column) { return in_array($column, $this-&gt;indexList($table)); } } The code is pretty much self explanatory but it's contains a template on which we can understand the code better: Please note that X is relate to the part we need to take care of: db, table or index AKA responsibility segment XCreate(): Create X in the responsibility segment. XDrop(): Remove X from responsibility segment. XList(): Return list of X responsibility segment. XExists(): Check if we already have a matching entity in the responsibility segment.","tags":"","url":"The_DB_layer\/Writing_a_custom_driver\/Operation.html"},{"title":"Query","text":"The query part will help you to search for stuff in the DB. Let's have a look on the code: &lt;?php namespace Nuntius\\Db\\RethinkDB; use Nuntius\\Db\\DbQueryHandlerInterface; use r\\Exceptions\\RqlException; use r\\ValuedQuery\\RVar; \/** * RethinkDB query handler. *\/ class RethinkDbQueryHandler implements DbQueryHandlerInterface { \/** * {@inheritdoc} *\/ public function table($table) { $this-&gt;table = $table; return $this; } \/** * {@inheritdoc} *\/ public function condition($property, $value, $operator = '=') { $this-&gt;conditions[] = [ 'property' =&gt; $property, 'value' =&gt; $value, 'operator' =&gt; $operator, ]; return $this; } \/** * {@inheritdoc} *\/ public function pager($start, $length) { $this-&gt;range = [ 'start' =&gt; $start, 'length' =&gt; $length, ]; return $this; } \/** * {@inheritdoc} *\/ public function orderBy($field, $direction) { $this-&gt;sort[] = [ 'field' =&gt; $field, 'direction' =&gt; $direction, ]; return $this; } \/** * Set the mode of the changes flag. * * @param bool $mode * The mode of the flag. * * @return RethinkDbQueryHandler * The current instance. *\/ public function setChanges($mode = TRUE) { $this-&gt;changes = $mode; return $this; } \/** * Return the changes flag. * * @return bool *\/ public function getChanges() { return $this-&gt;changes; } \/** * {@inheritdoc} *\/ public function execute() { $query = \\r\\table($this-&gt;table); if ($this-&gt;conditions) { foreach ($this-&gt;conditions as $condition) { $operator = !empty($condition['operator']) ? $condition['operator'] : '='; if (!in_array($operator, array_keys($this-&gt;operators))) { throw new RqlException(&quot;The operator {$operator} does not allowed. Only &quot; . implode(', ', array_keys($this-&gt;operators))); } if ($operator == 'IN') { $row = function(RVar $doc) use ($condition) { return \\r\\expr($condition['value'])-&gt;contains($doc-&gt;getField($condition['property'])); }; } else { $row = \\r\\row($condition['property'])-&gt;{$this-&gt;operators[$operator]}($condition['value']); } $query = $query-&gt;filter($row); } } if ($this-&gt;range) { $query = $query-&gt;slice($this-&gt;range['start'], $this-&gt;range['length']); } if ($this-&gt;sort) { foreach ($this-&gt;sort as $sort) { $sort['field'] = empty($sort['field']) ? 'id' : $sort['field']; $sort_object = $sort['direction'] == 'ASC' ? \\r\\asc($sort['field']) : \\r\\desc($sort['field']); $query = $query-&gt;orderBy($sort_object); } } if ($this-&gt;changes) { return $query-&gt;changes()-&gt;run($this-&gt;rethinkDB-&gt;getConnection()); } $items = []; foreach ($query-&gt;run($this-&gt;rethinkDB-&gt;getConnection()) as $item) { $item_copy = $item-&gt;getArrayCopy(); $items[] = $item_copy; } $this-&gt;cleanUp(); return $items; } \/** * {@inheritdoc} *\/ public function cleanUp() { $this-&gt;table = ''; $this-&gt;conditions = []; $this-&gt;sort = []; $this-&gt;range = []; } } Each method is pretty explained in the docs and name. Except for the cleanUp(). That's one is important since there are parts that use the same object to query the DB. The clean up method remove query settings from previous and promise the query will be done with out any issues.","tags":"","url":"The_DB_layer\/Writing_a_custom_driver\/Query.html"},{"title":"Storage","text":"The storage part handles the CRUD operation on tables in the DB. Let's look on RethinkDB implementation: &lt;?php \/** * RethinkDB storage handler. *\/ class RethinkDbStorageHandler implements DbStorageHandlerInterface { \/** * Constructing. *\/ function __construct() { $this-&gt;rethinkdb = Nuntius::getRethinkDB(); $this-&gt;connection = $this-&gt;rethinkdb-&gt;getConnection(); } \/** * {@inheritdoc} *\/ public function table($table) { $this-&gt;table = $table; return $this; } \/** * Get the table handler. * * @return \\r\\Queries\\Tables\\Table *\/ public function getTable() { return \\r\\db(Nuntius::getSettings()-&gt;getSetting('rethinkdb')['db']) -&gt;table($this-&gt;table); } \/** * {@inheritdoc} *\/ public function save($document) { if (!isset($document['time'])) { $document['time'] = time(); } $result = $this-&gt;getTable()-&gt;insert($document)-&gt;run($this-&gt;connection)-&gt;getArrayCopy(); if (!isset($document['id'])) { $document['id'] = isset($result['generated_keys']) ? reset($result['generated_keys']) : $result['id']; } return $document; } \/** * {@inheritdoc} *\/ public function load($id) { $items = $this-&gt;loadMultiple(array($id)); return reset($items); } \/** * {@inheritdoc} *\/ public function loadMultiple(array $ids = []) { $query = Nuntius::getDb()-&gt;getQuery() -&gt;table($this-&gt;table); if ($ids) { $query-&gt;condition('id', $ids, 'IN'); } return $query-&gt;execute(); } \/** * {@inheritdoc} *\/ public function update($document) { $this-&gt;getTable()-&gt;get($document['id'])-&gt;update($document)-&gt;run($this-&gt;connection); return $document; } \/** * {@inheritdoc} *\/ public function delete($id) { $this-&gt;deleteMultiple([$id]); } \/** * {@inheritdoc} *\/ public function deleteMultiple(array $ids = []) { $query = $this-&gt;getTable(); if ($ids) { $query-&gt;getAll(\\r\\args($ids)); } $query-&gt;delete()-&gt;run($this-&gt;connection); } } Let's have a quick look on the methods: save(): Inserting information into the DB. load(): Loading specific ID from the DB. loadMultiple(): Loading couple or all the items from the DB(when no IDs was passed). update(): Update a given object in the DB. The passed object must contain the ID of the entry. delete(): Deleting a specific item form the DB. deleteMultiple(): Similar to loadMultiple but for deleting - if not IDs was passed then deleting all the entries in the table.","tags":"","url":"The_DB_layer\/Writing_a_custom_driver\/Storage.html"},{"title":"Managers","text":"Get the settings: &lt;?php \\Nuntius\\Nuntius::getSettings(); Get the DB layer: &lt;?php \\Nuntius\\Nuntius::getRethinkDB(); Get the entity manager: &lt;?php \\Nuntius\\Nuntius::getEntityManager(); Get the task manager: &lt;?php \\Nuntius\\Nuntius::getTasksManager(); Get the update manager: &lt;?php \\Nuntius\\Nuntius::getUpdateManager();","tags":"","url":"Uncovered_API\/Managers.html"},{"title":"Slack how to","text":"How to send a message to the user: &lt;?php namespace Nuntius\\Plugin; \/** * Class Message. * * Triggered when a message eas sent. *\/ class Message extends NuntiusPluginAbstract { \/** * {@inheritdoc} *\/ public function action() { $this-&gt;client-&gt;getDMByUserId('USER_ID')-&gt;then(function (ChannelInterface $channel) { $this-&gt;client-&gt;send('Hi user!', $channel); }); } } Send message in a room: &lt;?php namespace Nuntius\\Plugin; \/** * Class Message. * * Triggered when a message eas sent. *\/ class Message extends NuntiusPluginAbstract { \/** * {@inheritdoc} *\/ public function action() { $this-&gt;client-&gt;getChannelById('ROOM_ID')-&gt;then(function (ChannelInterface $channel) { $this-&gt;client-&gt;send('Hi there room members', $channel); }); } } Send a message to a user when outside a room context AKA HTTP RPC-style: &lt;?php $slack_http = new SlackHttpService(); $slack = $slack_http-&gt;setAccessToken(Nuntius::getSettings()-&gt;getSetting('access_token')); $im_room = $slack-&gt;Im()-&gt;getImForUser($slack-&gt;Users()-&gt;getUserByName(strtolower($info['username']))); $message = new SlackHttpPayloadServicePostMessage(); $message -&gt;setChannel($im_room) -&gt;setText($info['text']); \/\/ Posting the message. $slack-&gt;Chat()-&gt;postMessage($message); For more options look on \\Nuntius\\Examples\\GitHubOpened\\NuntiusGitHubOpenedExample::postMessage","tags":"","url":"Uncovered_API\/Slack_how_to.html"},{"title":"Tests","text":"In order to test GitHub webhooks set the local env variable NUNTIUS_BASE_URL to the address of your nuntius installation: export NUNTIUS_BASE_URL=http:\/\/localhost:8888 After that fire up the test server: php -S localhost:8888 Running tests is easy: bash tests.sh","tags":"","url":"Tests.html"},{"title":"Intro","text":"Drupal is one of the most common CMS systems. It runs the white house, NBA, Pfizer and much more. Gizra, the company which was the reason Nuntius created, works with Drupal(and even more) so this is why doing the first use case on Drupal is pretty obvious. We going to demonstrate how to publish messages in a Slack room and Facebook Messenger when we have a new content in the site. Let's dive in!","tags":"","url":"Use_cases\/Drupal\/Intro.html"},{"title":"Setting up Drupal","text":"We will begin by downloading the Nuntius Drupal integration and enable it. Now, under admin\/config\/system\/nuntius we will set the settings in the next form: Let's go over the settings: Nuntius token - this is a token which help us validate the incoming webhooks. Nuntius slack address - Drupal will send information to this end point. Nuntius facebook address - Same as the above but oriented for Facebook Messenger. Slack room - The target slack room to post the messages. Don't forget to add Nuntius user as a member of that room.","tags":"","url":"Use_cases\/Drupal\/Setting_up_Drupal.html"},{"title":"Setting up Nuntius","text":"After setting up Drupal, let's set up Nuntius for that. We will start by editing hooks.local.yml file: entities: fb_reminders: '\\Nuntius\\Examples\\Drupal\\FbReminders' # List of updates. updates: 2: '\\Nuntius\\Examples\\Drupal\\AddFbReminder' # List of webhooks and te matcher handler. webhooks_routing: 'facebook': '\\Nuntius\\Examples\\Drupal\\DrupalExampleFacebook' 'drupal': '\\Nuntius\\Examples\\Drupal\\Drupal' 'facebook-drupal': '\\Nuntius\\Examples\\Drupal\\FacebookDrupal' # List of FB postback handlers. fb_postbacks: 'register_me': '\\Nuntius\\Examples\\Drupal\\RegisterMe' 'un_register_me': '\\Nuntius\\Examples\\Drupal\\UnRegisterMe' # Manage tasks. tasks: fb_manage_updates: '\\Nuntius\\Examples\\Drupal\\FacebookUpdatesManage' What's going on there? We added a new Entity to store the recipient IDs of the Facebook Messenger accounts we need to update. We created an update path to create the table of that entity. We specify the webhooks routing. We added FB postbacks items We added a new Facebook task to handle the incoming text. We also added the webhooks routing we defined in the Setting up Drupal section. In the next part we need to the token which will help us validate the incoming request. Update the credentials.local.yml by adding the Drupal token: drupal_token: 'me'","tags":"","url":"Use_cases\/Drupal\/Setting_up_Nuntius.html"},{"title":"How does it works","text":"So far, you set up the infrastructure for the updates. Now, let's see what going on there so you could implement a custom logic for your project. DB One of the things we did was to add an entity that will keep track the recipient IDs: entities: fb_reminders: '\\Nuntius\\Examples\\Drupal\\FbReminders' # List of updates. updates: 2: '\\Nuntius\\Examples\\Drupal\\AddFbReminder' For a new install you don't need to update path because - when installing nuntius all the entities are setted up for us. The update path dmonstrate how to add a new table for existing installations: \/** * Describe what the update going to do. * * @return string * What the update going to do. *\/ public function description() { return 'Adding the FB reminders entity'; } \/** * Running the update. * * @return string * A message for what the update did. *\/ public function update() { Nuntius::getDb()-&gt;getOperations()-&gt;tableCreate('fb_reminders'); return 'Adding the table.'; } Respond to text The user will probably asks us to Manage updates, for that we set a task handler: # Manage tasks. tasks: fb_manage_updates: '\\Nuntius\\Examples\\Drupal\\FacebookUpdatesManage' When he will send the message we will need to respond to the text: \/** * {@inheritdoc} *\/ public function scope() { return [ '\/Manage updates\/' =&gt; [ 'human_command' =&gt; 'Manage updates', 'description' =&gt; 'Managing helps in Facebook', 'callback' =&gt; [ 'facebook' =&gt; 'showUpdatesOptions' ], ], ]; } \/** * Manage updates options. *\/ public function showUpdatesOptions() { $send_api = Nuntius::facebookSendApi(); return $send_api-&gt;templates-&gt;button -&gt;text('What do you want to do?') -&gt;addButton($send_api-&gt;buttons-&gt;postBack-&gt;title('Update me')-&gt;payload('register_me')) -&gt;addButton($send_api-&gt;buttons-&gt;postBack-&gt;title(&quot;Don't update me&quot;)-&gt;payload('un_register_me')); } Webhooks routing. We added two new webhooks routing: # List of webhooks and te matcher handler. webhooks_routing: 'drupal': '\\Nuntius\\Examples\\Drupal\\Drupal' 'facebook-drupal': '\\Nuntius\\Examples\\Drupal\\FacebookDrupal' The webhooks will validate the token and post to Facebook\/Slack information about the new content. Handle the user choices The task returned a text with two payload buttons. But how we going to act? By defining the FB postbacks handlers we can register or un-register the user from updates through the messenger platform. Let's have a look on two examples. \\Nuntius\\Examples\\Drupal\\RegisterMe: \/** * {@inheritdoc} *\/ public function postBack() { \/\/ Check that the recipient is already registered. if ($this-&gt;queryForRecipient($this-&gt;fbRequest['sender'])) { return; } Nuntius::getEntityManager()-&gt;get('fb_reminders')-&gt;save(['recipient_id' =&gt; $this-&gt;fbRequest['sender']]); return 'Got it! You will be notified on new stuff'; } \\Nuntius\\Examples\\Drupal\\UnRegisterMe: \/** * {@inheritdoc} *\/ public function postBack() { $row = $this-&gt;queryForRecipient($this-&gt;fbRequest['sender']); Nuntius::getEntityManager()-&gt;get('fb_reminders')-&gt;delete($row[0]['id']); return &quot;You don't want to get updates. That's OK. See you in the future&quot;; } How the posting to FB and slack works After setting up all the stuff, let's see how the webhook routing post in the platform they design for. \\Nuntius\\Examples\\Drupal\\Drupal: \/** * {@inheritdoc} *\/ protected function trigger() { \/\/ Get the slack http service. $slack_http = new SlackHttpService(); $slack = $slack_http-&gt;setAccessToken(Nuntius::getSettings()-&gt;getSetting('access_token')); \/\/ Build the attachment. $attachment = new SlackHttpPayloadServiceAttachments(); $attachment -&gt;setColor('#36a64f') -&gt;setTitle($this-&gt;payload-&gt;title) -&gt;setTitleLink($this-&gt;url); if (!empty($this-&gt;payload-&gt;body-&gt;und[0]-&gt;value)) { $attachment-&gt;setText($this-&gt;payload-&gt;body-&gt;und[0]-&gt;value); } $attachments[] = $attachment; \/\/ Build the payload of the message. $message = new SlackHttpPayloadServicePostMessage(); $message -&gt;setChannel($this-&gt;slackRoom) -&gt;setAttachments($attachments) -&gt;setText('A new content on the site! Yay!'); \/\/ Posting the message. $slack-&gt;Chat()-&gt;postMessage($message); return new Response(); } And for facebook we have the next code, \\Nuntius\\Examples\\Drupal\\FacebookDrupal: \/** * {@inheritdoc} *\/ protected function trigger() { $subtitle = !empty($this-&gt;payload-&gt;body-&gt;und[0]-&gt;value) ? $this-&gt;payload-&gt;body-&gt;und[0]-&gt;value : ''; \/\/ Look for registered users from the given URL. if (!$users = Nuntius::getDb()-&gt;getQuery()-&gt;table('fb_reminders')-&gt;execute()) { return new Response(); } \/\/ Prepare the send API object. $send_api = Nuntius::facebookSendApi(); $send_api-&gt;setAccessToken(Nuntius::getSettings()-&gt;getSetting('fb_token')); $element = $send_api-&gt;templates-&gt;element; $payload = $send_api-&gt;templates-&gt;generic -&gt;addElement( $element -&gt;title($this-&gt;payload-&gt;title) -&gt;subtitle($subtitle) -&gt;addButton($send_api-&gt;buttons-&gt;url-&gt;title('Take me there!')-&gt;url($this-&gt;url)) ); \/\/ Loop over the users. foreach ($users as $user) { $send_api -&gt;setRecipientId($user['recipient_id']) -&gt;sendMessage($payload); } return new Response(); }","tags":"","url":"Use_cases\/Drupal\/How_does_it_works.html"},{"title":"See that in action","text":"To set up the updates manager in facebook it will like this: The user created a node in Drupal: The interaction in facebook looks like that: And in slack:","tags":"","url":"Use_cases\/Drupal\/See_that_in_action.html"}]}